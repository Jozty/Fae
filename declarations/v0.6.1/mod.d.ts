// This file auto-generated. Don't edit this file

// Generated by dts-bundle-generator v5.4.0

/** Placeholder for curried functions */
export declare const _: unique symbol;
declare const FUNCTION_LENGTH = "@@function/length";
/** Type of placeholder for curried functions */
export declare type PlaceHolder = typeof _;
export declare type PH = PlaceHolder;
/** Function type for curried function of arity 1 */
export interface Curry1<T, R = T> {
	(a?: PlaceHolder): Curry1<T, R>;
	(a: T): R;
}
/** Function type for curried function of arity 2 */
export interface Curry2<T1, T2 = T1, R = T1> {
	(t1?: PlaceHolder): Curry2<T1, T2, R>;
	(t1: T1): Curry1<T2, R>;
	(t1?: PlaceHolder, t2?: PlaceHolder): Curry2<T1, T2, R>;
	(t1: T1, t2?: PlaceHolder): Curry1<T2, R>;
	(t1: PlaceHolder, t2: T2): Curry1<T1, R>;
	(t1: T1, t2: T2): R;
}
/** Function type for curried function of arity 3 */
export interface Curry3<T1, T2 = T1, T3 = T1, R = T1> {
	(t1?: PlaceHolder): Curry3<T1, T2, T3, R>;
	(t1: T1): Curry2<T2, T3, R>;
	(t1?: PlaceHolder, t2?: PlaceHolder): Curry3<T1, T2, T3, R>;
	(t1: T1, t2?: PlaceHolder): Curry2<T2, T3, R>;
	(t1: PlaceHolder, t2: T2): Curry2<T1, T3, R>;
	(t1: T1, t2: T2): Curry1<T3, R>;
	(t1?: PlaceHolder, t2?: PlaceHolder, t3?: PlaceHolder): Curry3<T1, T2, T3, R>;
	(t1: T1, t2?: PlaceHolder, t3?: PlaceHolder): Curry2<T2, T3, R>;
	(t1: PlaceHolder, t2: T2, t3?: PlaceHolder): Curry2<T1, T3, R>;
	(t1: PlaceHolder, t2: PlaceHolder, t3: T3): Curry2<T1, T2, R>;
	(t1: T1, t2: T2, t3?: PlaceHolder): Curry1<T3, R>;
	(t1: PlaceHolder, t2: T2, t3: T3): Curry1<T1, R>;
	(t1: T1, t2: PlaceHolder, t3: T3): Curry1<T2, R>;
	(t1: T1, t2: T2, t3: T3): R;
}
export declare type Functor<T> = Iterable<T> | Iterator<T>;
export declare type FunctorWithArLk<T> = Functor<T> | ArrayLike<T>;
export declare type Func = ((...args: any[]) => any) & {
	[FUNCTION_LENGTH]?: number;
};
export declare type Obj<T = any> = {
	[key: string]: T;
};
export declare type ObjArr<T = any> = {
	[key: string]: T | T[];
};
export declare type ObjRec<T = any> = {
	[key: string]: ObjRec | ObjArr | string | number | null | undefined | T;
};
/** Comparator for functions like `sort` */
export declare type Comparator<T> = (a: T, b: T) => 1 | -1 | 0;
export declare type Predicate<T = any> = (...args: T[]) => boolean;
/** Predicate function type which checks one value `v` */
export declare type Predicate1<T = any> = (v: T) => boolean;
/** Predicate function type which applies on two values `a` and `b` */
export declare type Predicate2<T1, T2 = T1> = (a: T1, b: T2) => boolean;
/** Type for spec object which contains predicate functions of type {Predicate1} */
export declare type Tests<T> = {
	[key: string]: Predicate1<T>;
};
export declare type FuncArr1<T, R> = (a: T) => R;
export declare type FuncArr2<T1, T2, R> = (a: T1, b: T2) => R;
/** All the types which are returned by function `typ` */
export declare type AllTypes = "Null" | "Undefined" | "Object" | "Number" | "Boolean" | "String" | "Array" | "RegExp" | "Function" | "Arguments" | "Date" | "Error" | "Map" | "Set" | "WeakMap" | "WeakSet" | "Int8Array" | "Uint8Array" | "Uint8ClampedArray" | "Int16Array" | "Uint16Array" | "Int32Array" | "Uint32Array" | "Float32Array" | "Float64Array" | "ArrayBuffer";
export declare type Add_2 = ((b: number) => number) & ((b?: PH) => Add_2);
export declare type Add_1 = ((a: number) => number) & ((a?: PH) => Add_1);
export declare type Add = ((a: number, b: number) => number) & ((a: number, b?: PH) => Add_2) & ((a: PH, b: number) => Add_1) & ((a?: PH, b?: PH) => Add);
/**
 * Adds two numbers
 *
 *      const add5 = Fae.add(5, Fae._)
 *      const a = add5(4) // 9
 */
export declare const add: Add;
export declare type AddIndex = ((fn: Func) => Func) & ((fn?: PH) => AddIndex);
/**
 * Returns a new iteration function from the passed function
 * by adding two more parameters to its callback function
 * 1. the current index
 * 2. the entire list
 * The passed function must have first argument as the iteration functions
 * and last arguments as the list
 * @function
 *
 *      const indexedMap = Fae.addIndex(Fae.map)
 *      indexedMap((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r'])
 *      // ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
 */
export declare const addIndex: AddIndex;
export declare type Adjust_1<T> = ((index: number) => T[]) & ((index?: PH) => Adjust_1<T>);
export declare type Adjust_2<T> = ((fn: Func) => T[]) & ((fn?: PH) => Adjust_2<T>);
export declare type Adjust_3 = (<T>(list: T[]) => T[]) & ((list?: PH) => Adjust_3);
export declare type Adjust_2_3 = (<T>(fn: Func, list: T[]) => T[]) & ((fn: Func, list?: PH) => Adjust_3) & (<T>(fn: PH, list: T[]) => Adjust_2<T>) & ((fn?: PH, list?: PH) => Adjust_2_3);
export declare type Adjust_1_3 = (<T>(index: number, list: T[]) => T[]) & ((index: number, list?: PH) => Adjust_3) & (<T>(index: PH, list: T[]) => Adjust_1<T>) & ((index?: PH, list?: PH) => Adjust_1_3);
export declare type Adjust_1_2<T> = ((index: number, fn: Func) => T[]) & ((index: number, fn?: PH) => Adjust_2<T>) & ((index: PH, fn: Func) => Adjust_1<T>) & ((index?: PH, fn?: PH) => Adjust_1_2<T>);
export declare type Adjust = (<T>(index: number, fn: Func, list: T[]) => T[]) & ((index?: PH, fn?: PH, list?: PH) => Adjust) & ((index: number, fn?: PH, list?: PH) => Adjust_2_3) & ((index: PH, fn: Func, list?: PH) => Adjust_1_3) & (<T>(index: PH, fn: PH, list: T[]) => Adjust_1_2<T>) & ((index: number, fn: Func, list?: PH) => Adjust_3) & (<T>(index: number, fn: PH, list: T[]) => Adjust_2<T>) & (<T>(index: PH, fn: Func, list: T[]) => Adjust_1<T>);
/**
 * Applies a given function `fn` at given `index` of `list`,
 * returning a new copy of `list` with element at `index` replaced with
 * return value of `fn`.
 *
 *      Fae.adjust(2, Fae.add(1), [0, 1, 2, 3]) // [0, 1, 3, 3]
 *      Fae.adjust(-3, Fae.add(1), [0, 1, 2, 3]) // [0, 2, 2, 3]
 */
export declare const adjust: Adjust;
export declare type All_2<T> = ((functor: ArrayLike<T>) => boolean) & ((functor?: PH) => All_2<T>);
export declare type All_1<T> = ((predicate: Predicate1<T>) => boolean) & ((predicate?: PH) => All_1<T>);
export declare type All = (<T>(predicate: Predicate1<T>, functor: ArrayLike<T>) => boolean) & (<T>(predicate: Predicate1<T>, functor?: PH) => All_2<T>) & (<T>(predicate: PH, functor: ArrayLike<T>) => All_1<T>) & ((predicate?: PH, functor?: PH) => All);
/**
 * Return `true` if all the elements of the functor match `predicate`
 * `false` otherwise
 *
 * Acts as a transducer if a transformer is passed in place of `functor`
 */
export declare const all: All;
export declare type AllPass = (<T>(predicates: Predicate<T>[]) => Func) & ((predicates?: PH) => AllPass);
/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if every one of the provided predicates is satisfied
 * by those arguments.
 *
 */
export declare const allPass: AllPass;
export declare type Always = (<T>(value: T) => () => T) & ((value?: PH) => Always);
/**
 * Returns a function which that always returns `value`
 *
 *      const f = Fae.always('Fae')
 *      f() // 'Fae'
 */
export declare const always: Always;
export declare type And_2<T1> = (<T2>(b: T2) => T1 | T2) & ((b?: PH) => And_2<T1>);
export declare type And_1<T2> = (<T1>(a: T1) => T1 | T2) & ((a?: PH) => And_1<T2>);
export declare type And = (<T1, T2>(a: T1, b: T2) => T1 | T2) & (<T1>(a: T1, b?: PH) => And_2<T1>) & (<T2>(a: PH, b: T2) => And_1<T2>) & ((a?: PH, b?: PH) => And);
/**
 * Returns `true` if both arguments are `true`, `false` otherwise.
 *
 *      Fae.and(true, true)   //=> true
 *      Fae.and(true, false)  //=> false
 *      Fae.and(false, true)  //=> false
 *      Fae.and(false, false) //=> false
 */
export declare const and: And;
export declare type AndThen_2 = ((p: any) => PromiseLike<any>) & ((b?: PH) => AndThen_2);
export declare type AndThen_1 = ((f: Func) => PromiseLike<any>) & ((a?: PH) => AndThen_1);
export declare type AndThen = ((f: Func, p: any) => PromiseLike<any>) & ((f: Func, b?: PH) => AndThen_2) & ((a: PH, p: any) => AndThen_1) & ((a?: PH, b?: PH) => AndThen);
/**
 * Returns the result of applying the onSuccess function to the value inside
 * a successfully resolved promise. This is useful for working with promises
 * inside function compositions.
 */
export declare const andThen: AndThen;
export declare type Any_2<T> = ((list: T[]) => boolean) & ((list?: PH) => Any_2<T>);
export declare type Any_1<T> = ((predicate: Predicate1<T>) => boolean) & ((predicate?: PH) => Any_1<T>);
export declare type Any = (<T>(predicate: Predicate1<T>, list: T[]) => boolean) & (<T>(predicate: Predicate1<T>, list?: PH) => Any_2<T>) & (<T>(predicate: PH, list: T[]) => Any_1<T>) & ((predicate?: PH, list?: PH) => Any);
/**
 * Return `true` if any the elements of the list match `predicate`
 * `false` otherwise
 *
 * Acts as a transducer if a transformer is passed in place of `list`
 */
export declare const any: Any;
export declare type AnyPass = (<T>(predicates: Predicate<T>[]) => Func) & ((predicates?: PH) => AnyPass);
/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if at least one of the provided predicates is
 * satisfied by those arguments.
 */
export declare const anyPass: AnyPass;
export declare type ApplyFAp<T = any, R = any> = {
	ap: FuncArr1<T[] | Func | T, R>;
};
export declare type ApplyF<T = any, R = any> = FuncArr1<T, R> | FuncArr1<T, R>[] | ApplyFAp<T, R>;
/**
 *Iit applies a list of functions to a list of values.
 * Dispatches to the `ap` method of the second argument, if present. Also
 * treats curried functions as applicatives.
 *
 *      const mul2 = Fae.multiply(2)
 *      const add3 = Fae.add(3)
 *      Fae.ap([mul2, add3], [1, 2, 3]) // [2, 4, 6, 4, 5, 6])
 *      const h = Fae.ap(f, mul2)
 *      h(10) // 10 + (10 * 2))
 *      const obj = {ap: (n: number) => 'called ap with ' + n}
 *      Fae.ap(obj, 10) // 'called ap with 10'
*/
export declare const ap: Curry2<ApplyF, any, any>;
export declare type Aperture_2 = (<T>(list: T[]) => T[][]) & ((list?: PH) => Aperture_2);
export declare type Aperture_1<T> = ((n: number) => T[][]) & ((n?: PH) => Aperture_1<T>);
export declare type Aperture = (<T>(n: number, list: T[]) => T[][]) & ((n: number, list?: PH) => Aperture_2) & (<T>(n: PH, list: T[]) => Aperture_1<T>) & ((n?: PH, list?: PH) => Aperture);
/**
 * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
 * greater than the length of the list, an empty list is returned.
 *
 * Acts as a transducer if a transformer is passed in place of `list`
 */
export declare const aperture: Aperture;
export declare type Append_2<T> = ((list: T[]) => T[]) & ((list?: PH) => Append_2<T>);
export declare type Append_1<T> = ((el: T) => T[]) & ((el?: PH) => Append_1<T>);
export declare type Append = (<T>(el: T, list: T[]) => T[]) & (<T>(el: T, list?: PH) => Append_2<T>) & (<T>(el: PH, list: T[]) => Append_1<T>) & ((el?: PH, list?: PH) => Append);
/**
 * Add the `el` to the end of `list` and returns new list without affecting original
 *
 *
 *      Fae.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
 *      Fae.append('tests', []); //=> ['tests']
 *      Fae.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
 */
export declare const append: Append;
export declare type Assoc_1 = ((prop: string | number) => ObjRec) & ((prop?: PH) => Assoc_1);
export declare type Assoc_2 = ((val: any) => ObjRec) & ((val?: PH) => Assoc_2);
export declare type Assoc_3 = ((obj: ObjRec) => ObjRec) & ((obj?: PH) => Assoc_3);
export declare type Assoc_2_3 = ((val: any, obj: ObjRec) => ObjRec) & ((val: any, obj?: PH) => Assoc_3) & ((val: PH, obj: ObjRec) => Assoc_2) & ((val?: PH, obj?: PH) => Assoc_2_3);
export declare type Assoc_1_3 = ((prop: string | number, obj: ObjRec) => ObjRec) & ((prop: string | number, obj?: PH) => Assoc_3) & ((prop: PH, obj: ObjRec) => Assoc_1) & ((prop?: PH, obj?: PH) => Assoc_1_3);
export declare type Assoc_1_2 = ((prop: string | number, val: any) => ObjRec) & ((prop: string | number, val?: PH) => Assoc_2) & ((prop: PH, val: any) => Assoc_1) & ((prop?: PH, val?: PH) => Assoc_1_2);
export declare type Assoc = ((prop: string | number, val: any, obj: ObjRec) => ObjRec) & ((prop?: PH, val?: PH, obj?: PH) => Assoc) & ((prop: string | number, val?: PH, obj?: PH) => Assoc_2_3) & ((prop: PH, val: any, obj?: PH) => Assoc_1_3) & ((prop: PH, val: PH, obj: ObjRec) => Assoc_1_2) & ((prop: string | number, val: any, obj?: PH) => Assoc_3) & ((prop: string | number, val: PH, obj: ObjRec) => Assoc_2) & ((prop: PH, val: any, obj: ObjRec) => Assoc_1);
/**
 * Makes a shallow clone of `obj`, setting or overriding the specified
 * property `prop` with the given `val`. All non-primitive properties are
 * copied by reference.
 *
 *      Fae.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
 */
export declare const assoc: Assoc;
export declare type Path = string | Array<string | number>;
export declare type Paths_2 = (<T, R>(obj: ObjRec<T> | null) => R[]) & ((obj?: PH) => Paths_2);
export declare type Paths_1<T, R> = ((pathsArr: Path[]) => R[]) & ((pathsArr?: PH) => Paths_1<T, R>);
export declare type Paths = (<T, R>(pathsArr: Path[], obj: ObjRec<T> | null) => R[]) & ((pathsArr: Path[], obj?: PH) => Paths_2) & (<T, R>(pathsArr: PH, obj: ObjRec<T> | null) => Paths_1<T, R>) & ((pathsArr?: PH, obj?: PH) => Paths);
/**
 * Retrieves the values at given paths `pathsArr` of `obj`.
 * Each path in the `pathsArr` may be any array of keys or
 * string of keys separated by `/` or `.` .
 *
 *
 *      Fae.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); // [2, 3]
 *      Fae.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); // [2, undefined]
 *      Fae.path([['a', 'b']], {a: {b: 2}}); 2
 *      Fae.path(['a/b/0'], {a: {b: [1, 2, 3]}}); // 1
 *      Fae.path(['a.b.0'], {a: {b: [1, 2, 3]}}); // 2
 */
export declare const paths: Paths;
export declare type AssocPath_1 = ((path: Path) => ObjRec) & ((path?: PH) => AssocPath_1);
export declare type AssocPath_2 = ((val: any) => ObjRec) & ((val?: PH) => AssocPath_2);
export declare type AssocPath_3 = ((obj: ObjRec) => ObjRec) & ((obj?: PH) => AssocPath_3);
export declare type AssocPath_2_3 = ((val: any, obj: ObjRec) => ObjRec) & ((val: any, obj?: PH) => AssocPath_3) & ((val: PH, obj: ObjRec) => AssocPath_2) & ((val?: PH, obj?: PH) => AssocPath_2_3);
export declare type AssocPath_1_3 = ((path: Path, obj: ObjRec) => ObjRec) & ((path: Path, obj?: PH) => AssocPath_3) & ((path: PH, obj: ObjRec) => AssocPath_1) & ((path?: PH, obj?: PH) => AssocPath_1_3);
export declare type AssocPath_1_2 = ((path: Path, val: any) => ObjRec) & ((path: Path, val?: PH) => AssocPath_2) & ((path: PH, val: any) => AssocPath_1) & ((path?: PH, val?: PH) => AssocPath_1_2);
export declare type AssocPath = ((path: Path, val: any, obj: ObjRec) => ObjRec) & ((path?: PH, val?: PH, obj?: PH) => AssocPath) & ((path: Path, val?: PH, obj?: PH) => AssocPath_2_3) & ((path: PH, val: any, obj?: PH) => AssocPath_1_3) & ((path: PH, val: PH, obj: ObjRec) => AssocPath_1_2) & ((path: Path, val: any, obj?: PH) => AssocPath_3) & ((path: Path, val: PH, obj: ObjRec) => AssocPath_2) & ((path: PH, val: any, obj: ObjRec) => AssocPath_1);
/**
 * Makes a shallow clone of an object, setting or overriding the nodes required
 * to create the given path, and placing the specific value at the tail end of
 * that path. Note that this copies and flattens prototype properties onto the
 * new object as well. All non-primitive properties are copied by reference.
 *
 *      Fae.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
 *      Fae.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
 *
 */
export declare const assocPath: AssocPath;
export declare type Both_2<T> = ((g: T) => T) & ((g?: PH) => Both_2<T>);
export declare type Both_1<T> = ((f: T) => T) & ((f?: PH) => Both_1<T>);
export declare type Both = (<T>(f: T, g: T) => T) & (<T>(f: T, g?: PH) => Both_2<T>) & (<T>(f: PH, g: T) => Both_1<T>) & ((f?: PH, g?: PH) => Both);
/**
 * A function which calls the two provided functions and returns the `&&`
 * of the results.
 * It returns the result of the first function if it is false and the result
 * of the second function otherwise. Second function will not be invoked if the first returns a
 * false value.
 *
 */
export declare const both: Both;
export declare const chain: Curry2<Func, ArrayLike<any>, boolean>;
export declare type Clamp_1<T> = ((min: T) => T) & ((min?: PH) => Clamp_1<T>);
export declare type Clamp_2<T> = ((max: T) => T) & ((max?: PH) => Clamp_2<T>);
export declare type Clamp_3<T> = ((value: T) => T) & ((value?: PH) => Clamp_3<T>);
export declare type Clamp_2_3<T> = ((max: T, value: T) => T) & ((max: T, value?: PH) => Clamp_3<T>) & ((max: PH, value: T) => Clamp_2<T>) & ((max?: PH, value?: PH) => Clamp_2_3<T>);
export declare type Clamp_1_3<T> = ((min: T, value: T) => T) & ((min: T, value?: PH) => Clamp_3<T>) & ((min: PH, value: T) => Clamp_1<T>) & ((min?: PH, value?: PH) => Clamp_1_3<T>);
export declare type Clamp_1_2<T> = ((min: T, max: T) => T) & ((min: T, max?: PH) => Clamp_2<T>) & ((min: PH, max: T) => Clamp_1<T>) & ((min?: PH, max?: PH) => Clamp_1_2<T>);
export declare type Clamp = (<T>(min: T, max: T, value: T) => T) & (<T>(min?: PH, max?: PH, value?: PH) => Clamp) & (<T>(min: T, max?: PH, value?: PH) => Clamp_2_3<T>) & (<T>(min: PH, max: T, value?: PH) => Clamp_1_3<T>) & (<T>(min: PH, max: PH, value: T) => Clamp_1_2<T>) & (<T>(min: T, max: T, value?: PH) => Clamp_3<T>) & (<T>(min: T, max: PH, value: T) => Clamp_2<T>) & (<T>(min: PH, max: T, value: T) => Clamp_1<T>);
/**
 * Restricts `value` between `min` and `max`.
 * Returns `min` if `value < min`, `max` if `value > max`, `value` otherwise
 *
 *
 *      Fae.clamp(1, 10, -5) // => 1
 *      Fae.clamp(1, 10, 15) // => 10
 *      Fae.clamp(1, 10, 4)  // => 4
 */
export declare const clamp: Clamp;
/**
 * Returns a comparator out of `predicate` which returns `true` when
 * its first argument is less than the second, `false` otherwise
 */
export declare function comparator<T>(predicate: Predicate2<T, T>): Comparator<T>;
export declare type Complement = (<T extends any[]>(a: (...args: T) => boolean) => ((...args: T) => boolean)) & ((fn?: PH) => Complement);
export declare const complement: Complement;
/**
 * Performs a right-to-left function composition.
 * The last function may have any number of arguments;
 * the remaining must have single argument.
 * **Note:** The returned function is automatically curried
 *
 *
 *      const classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      const yellGreeting = Fae.compose((x: string) => x.toUpperCase(), classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      Fae.compose(Math.abs, Fae.add(1), Fae.multiply(2))(-4) //=> 7
 */
export declare function compose(this: any, ...functions: Func[]): any;
export declare type Concat_2<L extends T[] | string, T> = ((b: L) => L) & ((b?: PH) => Concat_2<L, T>);
export declare type Concat_1<L extends T[] | string, T> = ((a: L) => L) & ((a?: PH) => Concat_1<L, T>);
export declare type Concat = (<L extends T[] | string, T>(a: L, b: L) => L) & (<L extends T[] | string, T>(a: L, b?: PH) => Concat_2<L, T>) & (<L extends T[] | string, T>(a: PH, b: L) => Concat_1<L, T>) & ((a?: PH, b?: PH) => Concat);
/**
 * Concat two arrays or strings.
 * Both the arguments passed must be of same type.
 */
export declare const concat: Concat;
export declare type Contains_2<T> = ((list: ArrayLike<T>) => boolean) & ((list?: PH) => Contains_2<T>);
export declare type Contains_1<T> = ((element: T) => boolean) & ((element?: PH) => Contains_1<T>);
export declare type Contains = (<T>(element: T, list: ArrayLike<T>) => boolean) & (<T>(element: T, list?: PH) => Contains_2<T>) & (<T>(element: PH, list: ArrayLike<T>) => Contains_1<T>) & ((element?: PH, list?: PH) => Contains);
/**
 * Returns `true` or `false` based on the element found or not.
 */
export declare const contains: Contains;
export declare type CrossProduct_2<T1> = (<T2>(b: T2[]) => [
	T1,
	T2
][]) & ((b?: PH) => CrossProduct_2<T1>);
export declare type CrossProduct_1<T2> = (<T1>(a: T1[]) => [
	T1,
	T2
][]) & ((a?: PH) => CrossProduct_1<T2>);
export declare type CrossProduct = (<T1, T2>(a: T1[], b: T2[]) => [
	T1,
	T2
][]) & (<T1>(a: T1, b?: PH) => CrossProduct_2<T1>) & (<T2>(a: PH, b: T2[]) => CrossProduct_1<T2>) & ((a?: PH, b?: PH) => CrossProduct);
/**
 * Creates a new list out of the two supplied by creating each possible pair
 * from the list passed as arguments.
 *
 *     Fae.crossProduct([1, 2, 3], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b'], [3, 'a'], [3, 'b']]
 */
export declare const crossProduct: CrossProduct;
/**
 * Returns the curried function
 * **NOTE** The passed function will be called as soon as expected number
 * of arguments are received. Rest will be ignored.
 *
 *
 *      const f = (a, b, c) => [a, b, c]
 *      const g = curry(f.length, f)
 *      g(1, 2, 3) // [1, 2, 3]
 *      g(1)(2, 3) // [1, 2, 3]
 *      g(1)(2)(3) // [1, 2, 3]
 *      g(1, 2)(3) // [1, 2, 3]
 *      g(_, 2, 3)(1) // [1, 2, 3]
 *      g(_, _, 3)(1, 2) // [1, 2, 3]
 *      g(_, _, 3)(1, 2, 4, 5, 6) // 11 - rest arguments are ignored */
export declare const curry: Curry2<number, Func, Func>;
export declare type Dec = ((element: number) => number) & ((fnelement?: PH) => Dec);
/**
 * Decreases its argument by 1.
 */
export declare const dec: Dec;
export declare type DefaultTo_2<T1> = (<T2>(value: T2) => T1 | T2) & ((value?: PH) => DefaultTo_2<T1>);
export declare type DefaultTo_1<T2> = (<T1>(defaultV: T1) => T1 | T2) & ((defaultV?: PH) => DefaultTo_1<T2>);
export declare type DefaultTo = (<T1, T2>(defaultV: T1, value: T2) => T1 | T2) & (<T1>(defaultV: T1, value?: PH) => DefaultTo_2<T1>) & (<T2>(defaultV: PH, value: T2) => DefaultTo_1<T2>) & ((defaultV?: PH, value?: PH) => DefaultTo);
/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`;
 * otherwise the first argument is returned.
 *
 *
 *      const defaultTo125 = Fae.defaultTo(125)
 *
 *      defaultTo125(null)  //=> 125
 *      defaultTo125(undefined)  //=> 125
 *      defaultTo125(false)  //=> false
 *      defaultTo125('Fae')  //=> 'Fae'
 */
export declare const defaultTo: DefaultTo;
export declare type Dissoc_2 = ((obj: ObjRec) => ObjRec) & ((obj?: PH) => Dissoc_2);
export declare type Dissoc_1 = ((prop: string | number) => ObjRec) & ((prop?: PH) => Dissoc_1);
export declare type Dissoc = ((prop: string | number, obj: ObjRec) => ObjRec) & ((prop: string | number, obj?: PH) => Dissoc_2) & ((prop: PH, obj: ObjRec) => Dissoc_1) & ((prop?: PH, obj?: PH) => Dissoc);
/**
 * Makes a shallow clone of `obj`, deleting `props` from the new object.
 * All non-primitive properties are copied by reference.
 *
 *      Fae.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
 */
export declare const dissoc: Dissoc;
export declare type DissocPath_2 = ((obj: ObjRec) => ObjRec) & ((obj?: PH) => DissocPath_2);
export declare type DissocPath_1 = ((path: Path) => ObjRec) & ((path?: PH) => DissocPath_1);
export declare type DissocPathPath = ((path: Path, obj: ObjRec) => ObjRec) & ((path: Path, obj?: PH) => DissocPath_2) & ((path: PH, obj: ObjRec) => DissocPath_1) & ((path?: PH, obj?: PH) => DissocPathPath);
/**
 * Makes a shallow clone of an object `obj`, deleting value at
 * at the given `path`. Note that this copies and flattens prototype properties onto the
 * new object as well. All non-primitive properties are copied by reference.
 *
 *      Fae.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
 *
 */
export declare const dissocPath: DissocPathPath;
export declare type Divide_2 = ((b: number) => number) & ((b?: PH) => Divide_2);
export declare type Divide_1 = ((a: number) => number) & ((a?: PH) => Divide_1);
export declare type Divide = ((a: number, b: number) => number) & ((a: number, b?: PH) => Divide_2) & ((a: PH, b: number) => Divide_1) & ((a?: PH, b?: PH) => Divide);
/**
 * Divides two numbers. Equivalent to `a / b`.
 */
export declare const divide: Divide;
export declare type Drop_2 = (<L extends T[] | string, T>(list: L) => L) & ((list?: PH) => Drop_2);
export declare type Drop_1<L extends T[] | string, T> = ((n: number) => L) & ((n?: PH) => Drop_1<L, T>);
export declare type Drop = (<L extends T[] | string, T>(n: number, list: L) => L) & ((n: number, list?: PH) => Drop_2) & (<L extends T[] | string, T>(n: PH, list: L) => Drop_1<L, T>) & ((n?: PH, list?: PH) => Drop);
/**
 * Returns all but first `n` elements of given list.
 *
 * Acts as a transducer if a transformer is passed in place of `list`
 *
 *
 *      Fae.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      Fae.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
 *      Fae.drop(3, ['foo', 'bar', 'baz']); //=> []
 *      Fae.drop(4, ['foo', 'bar', 'baz']); //=> []
 *      Fae.drop(3, 'foobar');               //=> 'bar'
 */
export declare const drop: Drop;
export declare type DropLast_2 = (<L extends T[] | string, T>(list: L) => L) & ((list?: PH) => DropLast_2);
export declare type DropLast_1<L extends T[] | string, T> = ((n: number) => L) & ((n?: PH) => DropLast_1<L, T>);
export declare type DropLast = (<L extends T[] | string, T>(n: number, list: L) => L) & ((n: number, list?: PH) => DropLast_2) & (<L extends T[] | string, T>(n: PH, list: L) => DropLast_1<L, T>) & ((n?: PH, list?: PH) => DropLast);
/**
 * Returns all but last `n` elements of given list.
 *
 * Acts as a transducer if a transformer is passed in place of `list`
 *
 *
 *      Fae.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      Fae.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
 *      Fae.dropLast(3, ['foo', 'bar', 'baz']); //=> []
 *      Fae.dropLast(4, ['foo', 'bar', 'baz']); //=> []
 *      Fae.dropLast(3, 'foobar');               //=> 'foo'
 */
export declare const dropLast: DropLast;
export declare type DropLastWhile_2<L extends T[] | string, T> = ((list: L) => L) & ((list?: PH) => DropLastWhile_2<L, T>);
export declare type DropLastWhile_1<L extends T[] | string, T> = ((predicate: Predicate1<T>) => L) & ((predicate?: PH) => DropLastWhile_1<L, T>);
export declare type DropLastWhile = (<L extends T[] | string, T>(predicate: Predicate1<T>, list: L) => L) & (<L extends T[] | string, T>(predicate: Predicate1<T>, list?: PH) => DropLastWhile_2<L, T>) & (<L extends T[] | string, T>(predicate: PH, list: L) => DropLastWhile_1<L, T>) & ((predicate?: PH, list?: PH) => DropLastWhile);
/**
 * Returns a new list excluding the trailing elements of a `list` which
 * satisfies `predicate`. Skips all the elements which on applied on `predicate`
 * returns `true`. The new list ends with last `false`.
 *
 * Acts as a transducer if a transformer is passed in place of `list`
 *
 *
 *      const lteThree = x => x <= 3;
 *      Fae.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
 *      Fae.dropLastWhile(x => x !== 't' , 'dispatch'); //=> 'dispat'
 */
export declare const dropLastWhile: DropLastWhile;
export declare type DropRepeats = (<T>(list: T[]) => T[]) & ((list?: PH) => DropRepeats);
/**
 * Returns a new list without any consecutively repeating elements.
 * Fae.equals is used for comparison
 *
 *      Fae.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
 */
export declare const dropRepeats: DropRepeats;
export declare type DropRepeatsWith_2<T> = ((list: T[]) => T[]) & ((list?: PH) => DropRepeatsWith_2<T>);
export declare type DropRepeatsWith_1<T> = ((predicate: Predicate2<T>) => T[]) & ((predicate?: PH) => DropRepeatsWith_1<T>);
export declare type DropRepeatsWith = (<T>(predicate: Predicate2<T>, list: T[]) => T[]) & (<T>(predicate: Predicate2<T>, list?: PH) => DropRepeatsWith_2<T>) & (<T>(predicate: PH, list: T[]) => DropRepeatsWith_1<T>) & ((predicate?: PH, list?: PH) => DropRepeatsWith);
/**
 * Returns a new list without consecutively repeating elements.
 * Equality is decided by `predicate`
 *
 * Acts as a transducer if a transformer is given in `list` position.
 *
 *
 */
export declare const dropRepeatsWith: DropRepeatsWith;
export declare type DropWhile_2<L extends T[] | string, T> = ((functor: L) => L) & ((functor?: PH) => DropWhile_2<L, T>);
export declare type DropWhile_1<L extends T[] | string, T> = ((predicate: Predicate1<T>) => L) & ((predicate?: PH) => DropWhile_1<L, T>);
export declare type DropWhile = (<L extends T[] | string, T>(predicate: Predicate1<T>, functor: L) => L) & (<L extends T[] | string, T>(predicate: Predicate1<T>, functor?: PH) => DropWhile_2<L, T>) & (<L extends T[] | string, T>(predicate: PH, functor: L) => DropWhile_1<L, T>) & ((predicate?: PH, functor?: PH) => DropWhile);
/**
 * Returns a new list excluding the leading elements of a `functor` which
 * satisfies `predicate`. Skips all the elements which on applied on `predicate`
 * returns `true`. The new list starts with first `false`.
 *
 * Acts as a transducer if a transformer is passed in place of `functor`
 *
 *
 *      const lteTwo = x => x <= 2
 *      Fae.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
 *      Fae.dropWhile(x => x !== 't' , 'dispatch'); //=> 'tch'
 */
export declare const dropWhile: DropWhile;
export declare type Either_2<T> = ((g: T) => T) & ((g?: PH) => Either_2<T>);
export declare type Either_1<T> = ((f: T) => T) & ((f?: PH) => Either_1<T>);
export declare type Either = (<T>(f: T, g: T) => T) & (<T>(f: T, g?: PH) => Either_2<T>) & (<T>(f: PH, g: T) => Either_1<T>) & ((f?: PH, g?: PH) => Either);
/**
 * A function wrapping calls to the two functions in an `||` operation,
 * returning the result of the first function if it is true and the result
 * of the second function otherwise. Second function will not be invoked if the first returns a
 * true value.
 *
 *      const gt10 = x => x > 10
 *      const even = x => (x & 1) === 0
 *      const f = Fae.either(gt10, even)
 *      f(101) //=> true
 *      f(8) //=> true
 *
 */
export declare const either: Either;
export declare type Empty = (<T>(x: T) => T | Partial<T>) & ((fn?: PH) => Empty);
/**
 * Returns the empty value of its argument's type.
 * Dispatches to the `empty` method of the first argument, if present.
 *
 *      Fae.empty([1, 2, 3])     //=> []
 *      Fae.empty('unicorns')    //=> ''
 *      Fae.empty({x: 1, y: 2})  //=> {}
 */
export declare const empty: Empty;
export declare type EndsWith_2<L extends T[] | string, T> = ((functor: L) => boolean) & ((functor?: PH) => EndsWith_2<L, T>);
export declare type EndsWith_1<L extends T[] | string, T> = ((suffix: L) => boolean) & ((suffix?: PH) => EndsWith_1<L, T>);
export declare type EndsWith = (<L extends T[] | string, T>(suffix: L, functor: L) => boolean) & (<L extends T[] | string, T>(suffix: L, functor?: PH) => EndsWith_2<L, T>) & (<L extends T[] | string, T>(suffix: PH, functor: L) => EndsWith_1<L, T>) & ((suffix?: PH, functor?: PH) => EndsWith);
/**
 * checks if `functor` ends with `suffix`
 *
 *      Fae.endsWith('c', 'abc')                //=> true
 *      Fae.endsWith('b', 'abc')                //=> false
 *      Fae.endsWith(['c'], ['a', 'b', 'c'])    //=> true
 *      Fae.endsWith(['b'], ['a', 'b', 'c'])    //=> false
 *
 */
export declare const endsWith: EndsWith;
export declare type EqProps_1<T> = ((prop: string) => boolean) & ((prop?: PH) => EqProps_1<T>);
export declare type EqProps_2<T> = ((obj1: Obj<T>) => boolean) & ((obj1?: PH) => EqProps_2<T>);
export declare type EqProps_3<T> = ((obj2: Obj<T>) => boolean) & ((obj2?: PH) => EqProps_3<T>);
export declare type EqProps_2_3 = (<T>(obj1: Obj<T>, obj2: Obj<T>) => boolean) & (<T>(obj1: Obj<T>, obj2?: PH) => EqProps_3<T>) & (<T>(obj1: PH, obj2: Obj<T>) => EqProps_2<T>) & ((obj1?: PH, obj2?: PH) => EqProps_2_3);
export declare type EqProps_1_3<T> = ((prop: string, obj2: Obj<T>) => boolean) & ((prop: string, obj2?: PH) => EqProps_3<T>) & ((prop: PH, obj2: Obj<T>) => EqProps_1<T>) & ((prop?: PH, obj2?: PH) => EqProps_1_3<T>);
export declare type EqProps_1_2<T> = ((prop: string, obj1: Obj<T>) => boolean) & ((prop: string, obj1?: PH) => EqProps_2<T>) & ((prop: PH, obj1: Obj<T>) => EqProps_1<T>) & ((prop?: PH, obj1?: PH) => EqProps_1_2<T>);
export declare type EqProps = (<T>(prop: string, obj1: Obj<T>, obj2: Obj<T>) => boolean) & ((prop?: PH, obj1?: PH, obj2?: PH) => EqProps) & ((prop: string, obj1?: PH, obj2?: PH) => EqProps_2_3) & (<T>(prop: PH, obj1: Obj<T>, obj2?: PH) => EqProps_1_3<T>) & (<T>(prop: PH, obj1: PH, obj2: Obj<T>) => EqProps_1_2<T>) & (<T>(prop: string, obj1: Obj<T>, obj2?: PH) => EqProps_3<T>) & (<T>(prop: string, obj1: PH, obj2: Obj<T>) => EqProps_2<T>) & (<T>(prop: PH, obj1: Obj<T>, obj2: Obj<T>) => EqProps_1<T>);
/**
 * Reports whether two objects have the same value, for the specified property.
 * Useful as a curried predicate.
 *
 *      const obj1 = { a: 1, b: 2, c: 3, d: 4 }
 *      const obj2 = { a: 10, b: 20, c: 3, d: 40 }
 *      Fae.eqProps('a', obj1, obj2) //=> false
 *      Fae.eqProps('c', obj1, obj2) //=> true
 */
export declare const eqProps: EqProps;
export declare const equals: Curry2<any, any, boolean>;
export declare type Filter_2<T> = ((functor: FunctorWithArLk<T> | Obj<T>) => T[] | Partial<Obj<T>>) & ((functor?: PH) => Filter_2<T>);
export declare type Filter_1<T> = ((predicate: Predicate1<T>) => T[] | Partial<Obj<T>>) & ((predicate?: PH) => Filter_1<T>);
export declare type Filter = (<T>(predicate: Predicate1<T>, functor: FunctorWithArLk<T> | Obj<T>) => T[] | Partial<Obj<T>>) & (<T>(predicate: Predicate1<T>, functor?: PH) => Filter_2<T>) & (<T>(predicate: PH, functor: FunctorWithArLk<T> | Obj<T>) => Filter_1<T>) & ((predicate?: PH, functor?: PH) => Filter);
/**
 * Filters the those elements from `functor` that satisfies `predicate`.
 * The `functor` may be an array/object/iterable/iterator.
 *
 * Acts as a transducer if a transformer is passed in place of `functor`
 */
export declare const filter: Filter;
export declare type Find_2<T> = ((list: T[]) => T | undefined) & ((list?: PH) => Find_2<T>);
export declare type Find_1<T> = ((predicate: Predicate1<T>) => T | undefined) & ((predicate?: PH) => Find_1<T>);
export declare type Find = (<T>(predicate: Predicate1<T>, list: T[]) => T | undefined) & (<T>(predicate: Predicate1<T>, list?: PH) => Find_2<T>) & (<T>(predicate: PH, list: T[]) => Find_1<T>) & ((predicate?: PH, list?: PH) => Find);
/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Acts as a transducer if a transformer is passed in place of `list`
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}]
 *      Fae.find(Fae.propEq('a', 2))(xs) //=> {a: 2}
 *      Fae.find(Fae.propEq('a', 4))(xs) //=> undefined
 */
export declare const find: Find;
export declare type FindIndex_2<T> = ((element: T) => number) & ((element?: PH) => FindIndex_2<T>);
export declare type FindIndex_1<T> = ((arr: T[]) => number) & ((arr?: PH) => FindIndex_1<T>);
export declare type FindIndex = (<T>(arr: T[], element: T) => number) & (<T>(arr: T[], element?: PH) => FindIndex_2<T>) & (<T>(arr: PH, element: T) => FindIndex_1<T>) & ((arr?: PH, element?: PH) => FindIndex);
/**
 * Takes in Array and Element as its 2 parameters
 * Return the 1st index If element is matched or -1 is unmatched.
 */
export declare const findIndex: FindIndex;
export declare type FindLast_2<T> = ((list: T[]) => T | undefined) & ((list?: PH) => FindLast_2<T>);
export declare type FindLast_1<T> = ((predicate: Predicate1<T>) => T | undefined) & ((predicate?: PH) => FindLast_1<T>);
export declare type FindLast = (<T>(predicate: Predicate1<T>, list: T[]) => T | undefined) & (<T>(predicate: Predicate1<T>, list?: PH) => FindLast_2<T>) & (<T>(predicate: PH, list: T[]) => FindLast_1<T>) & ((predicate?: PH, list?: PH) => FindLast);
/**
 * Returns the last element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Acts as a transducer if a transformer is passed in place of `list`
 *
 *      const xs = [{a: 1, b: 0}, {a:1, b: 1}]
 *      Fae.findLast(Fae.propEq('a', 1))(xs) //=> {a: 1, b: 1}
 *      Fae.findLast(Fae.propEq('a', 4))(xs) //=> undefined
 */
export declare const findLast: FindLast;
export declare type FindLastIndex_2<T> = ((list: T[]) => number) & ((list?: PH) => FindLastIndex_2<T>);
export declare type FindLastIndex_1<T> = ((predicate: Predicate1<T>) => number) & ((predicate?: PH) => FindLastIndex_1<T>);
export declare type FindLastIndex = (<T>(predicate: Predicate1<T>, list: T[]) => number) & (<T>(predicate: Predicate1<T>, list?: PH) => FindLastIndex_2<T>) & (<T>(predicate: PH, list: T[]) => FindLastIndex_1<T>) & ((predicate?: PH, list?: PH) => FindLastIndex);
/**
 * Returns index of last element of the list which matches the predicate, or
 * `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is passed in place of `list`
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}]
 *      Fae.find(Fae.propEq('a', 2))(xs) //=> {a: 2}
 *      Fae.find(Fae.propEq('a', 4))(xs) //=> undefined
 */
export declare const findLastIndex: FindLastIndex;
/**
 * Returns a new function much like the supplied one, except that the first two
 * arguments' order is reversed.
 *
 *
 *      const mergeThree = (a, b, c) => [].concat(a, b, c)
 *      mergeThree(1, 2, 3); // [1, 2, 3]
 *      Fae.flip(mergeThree)(1, 2, 3); // [2, 1, 3]
 */
export declare function flip(fn: Func): (this: any, ...passed: any[]) => any;
export declare type FromPairs = (<T>(pairs: Pair<T>[]) => Record<string, T>) & ((pairs?: PH) => FromPairs);
export declare type Pair<T = any> = [
	string | number,
	T
];
/**
 * Creates a new object from a list key-value pairs. If a key appears in
 * multiple pairs, the rightmost pair is included in the object.
 *
 *      Fae.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
 */
export declare const fromPairs: FromPairs;
export declare type GroupWith_2<L extends T[] | string, T> = ((functor: L) => L[]) & ((functor?: PH) => GroupWith_2<L, T>);
export declare type GroupWith_1<L extends T[] | string, T> = ((predicate: Predicate2<T>) => L[]) & ((predicate?: PH) => GroupWith_1<L, T>);
export declare type GroupWith = (<L extends T[] | string, T>(predicate: Predicate2<T>, functor: L) => L[]) & (<L extends T[] | string, T>(predicate: Predicate2<T>, functor?: PH) => GroupWith_2<L, T>) & (<L extends T[] | string, T>(predicate: PH, functor: L) => GroupWith_1<L, T>) & ((predicate?: PH, functor?: PH) => GroupWith);
export declare const groupWith: GroupWith;
/**
 * Returns the first element of the given list or string. In some libraries
 * this function is named `first`.
 *
 *      Fae.head(['fi', 'fo', 'fum']); //=> 'fi'
 *      Fae.head([]); //=> undefined
 *
 *      Fae.head('abc'); //=> 'a'
 *      Fae.head(''); //=> ''
 */
export declare const head: (<F extends string | Iterable<T> | Iterator<T, any, undefined> | ArrayLike<T>, T>(functor: F) => T) & ((functor?: typeof import("./mod")._) => (<F extends string | Iterable<T> | Iterator<T, any, undefined> | ArrayLike<T>, T>(functor: F) => T) & any);
export declare type Identity = (<T>(x: T) => T) & ((x?: PH) => Identity);
/**
 * Returns the supplied parameter
 */
export declare const identity: Identity;
export declare type Inc = ((element: number) => number) & ((fnelement?: PH) => Inc);
/**
 * Increases its argument by 1.
 */
export declare const inc: Inc;
export declare type IndexOf_2<T> = ((list: T[]) => number) & ((list?: PH) => IndexOf_2<T>);
export declare type IndexOf_1<T> = ((value: T) => number) & ((value?: PH) => IndexOf_1<T>);
export declare type IndexOf = (<T>(value: T, list: T[]) => number) & (<T>(value: T, list?: PH) => IndexOf_2<T>) & (<T>(value: PH, list: T[]) => IndexOf_1<T>) & ((value?: PH, list?: PH) => IndexOf);
/**
 * Returns the position of the first occurrence of `value` in `list`, or -1
 * if the item is not included in the array. [`Fae.equals`](#equals) is used to
 * determine equality.
 *
 *      Fae.indexOf(3, [1,2,3,4]); //=> 2
 *      Fae.indexOf(10, [1,2,3,4]); //=> -1
 *      Fae.indexOf(0, [1, 2, 3, 0, -0, NaN]); //=> 3
 *      Fae.indexOf(-0, [1, 2, 3, 0, -0, NaN]); //=> 4
 *      Fae.indexOf(NaN, [1, 2, 3, 0, -0, NaN]); //=> 5
 */
export declare const indexOf: IndexOf;
export declare type Insert_1<T> = ((index: number) => T[]) & ((index?: PH) => Insert_1<T>);
export declare type Insert_2<T> = ((element: T) => T[]) & ((element?: PH) => Insert_2<T>);
export declare type Insert_3<T> = ((list: T[]) => T[]) & ((list?: PH) => Insert_3<T>);
export declare type Insert_2_3 = (<T>(element: T, list: T[]) => T[]) & (<T>(element: T, list?: PH) => Insert_3<T>) & (<T>(element: PH, list: T[]) => Insert_2<T>) & ((element?: PH, list?: PH) => Insert_2_3);
export declare type Insert_1_3<T> = ((index: number, list: T[]) => T[]) & ((index: number, list?: PH) => Insert_3<T>) & (<T>(index: PH, list: T[]) => Insert_1<T>) & ((index?: PH, list?: PH) => Insert_1_3<T>);
export declare type Insert_1_2<T> = ((index: number, element: T) => T[]) & ((index: number, element?: PH) => Insert_2<T>) & ((index: PH, element: T) => Insert_1<T>) & ((index?: PH, element?: PH) => Insert_1_2<T>);
export declare type Insert = (<T>(index: number, element: T, list: T[]) => T[]) & ((index?: PH, element?: PH, list?: PH) => Insert) & ((index: number, element?: PH, list?: PH) => Insert_2_3) & (<T>(index: PH, element: T, list?: PH) => Insert_1_3<T>) & (<T>(index: PH, element: PH, list: T[]) => Insert_1_2<T>) & (<T>(index: number, element: T, list?: PH) => Insert_3<T>) & (<T>(index: number, element: PH, list: T[]) => Insert_2<T>) & (<T>(index: PH, element: T, list: T[]) => Insert_1<T>);
/**
 * Returns a new array with `element` inserted at `index` to `list`
 * without affecting original one.
 */
export declare const insert: Insert;
export declare type IsEmpty = ((x: any) => boolean) & ((x?: PH) => IsEmpty);
/**
 * Returns `true` if the given value is its type's empty value, `false`
 * otherwise.
 *
 *      Fae.isEmpty([1, 2, 3])   //=> false
 *      Fae.isEmpty([])          //=> true
 *      Fae.isEmpty('')          //=> true
 *      Fae.isEmpty(null)        //=> false
 *      Fae.isEmpty({})          //=> true
 */
export declare const isEmpty: IsEmpty;
export declare type Join_2 = (<T>(functor: FunctorWithArLk<T>) => string) & ((functor?: PH) => Join_2);
export declare type Join_1<T> = ((separator: string | number) => string) & ((separator?: PH) => Join_1<T>);
export declare type Join = (<T>(separator: string | number, functor: FunctorWithArLk<T>) => string) & ((separator: string | number, functor?: PH) => Join_2) & (<T>(separator: PH, functor: FunctorWithArLk<T>) => Join_1<T>) & ((separator?: PH, functor?: PH) => Join);
/**
 * Returns a string made by inserting the `separator` between each element and
 * concatenating all the elements into a single string.
 * The functor may be array-like/iterable/iterator.
 */
export declare const join: Join;
export declare type LensF_2<T, F> = ((setter: Setter<T, F>) => Lens<T, F>) & ((setter?: PH) => LensF_2<T, F>);
export declare type LensF_1<T, F> = ((getter: Getter<T, F>) => Lens<T, F>) & ((getter?: PH) => LensF_1<T, F>);
export declare type LensF = (<T, F>(getter: Getter<T, F>, setter: Setter<T, F>) => Lens<T, F>) & (<T, F>(getter: Getter<T, F>, setter?: PH) => LensF_2<T, F>) & (<T, F>(getter: PH, setter: Setter<T, F>) => LensF_1<T, F>) & ((getter?: PH, setter?: PH) => LensF);
/** Getter for the lens */
export declare type Getter<T, F> = (target: T) => F;
/** Setter for the lens */
export declare type Setter<T, F> = (focus: F, target: T) => T;
/**
 * The function which is passed to the `Lens`.
 * It accepts one argument `focus` - the focused object
 * It returns `LensTransformer` type object
 */
export declare type GetTransformer<T, F, R> = (focus: F) => LensTransformer<T, F, R>;
/**
 * @property value
 * @property {(fn: (focus: any) => any) => any} func - function that is called during transformation.
 * a setter function is passed to it whose first argument which is to set to the `target`
 */
export declare type LensTransformer<T, F, R> = {
	value: F;
	func: (fn: (focus: F) => T) => LensTransformer<never, R, never>;
};
export declare type SeenGetTransformer<T, R> = (target: T) => LensTransformer<never, R, never>;
/**
 * Lens function which takes `GetTransformer` and returns `SeenGetTransformer`
 */
export declare type Lens<T, F> = <R>(getTransformer: GetTransformer<T, F, R>) => SeenGetTransformer<T, R>;
/**
 * Returns a lens for the given getter and setter functions. The `getter` "gets"
 * the value of the focus; the setter "sets" the value of the focus. The `setter`
 * should not mutate the data structure.
 */
export declare const lens: LensF;
export declare type LensIndex = (<T, F>(index: number) => Lens<T, F>) & ((index?: PH) => LensIndex);
/**
 * Returns a lens whose focus is the specified index.
 *
 *      const headLens = Fae.lensIndex(0)
 *      Fae.view(headLens, ['a', 'b', 'c'])            //=> 'a'
 *      Fae.set(headLens, 'x', ['a', 'b', 'c'])        //=> ['x', 'b', 'c']
 *      Fae.over(headLens, (x: string) => x.toUpperCase(), ['a', 'b', 'c']) //=> ['A', 'b', 'c']
 */
export declare const lensIndex: LensIndex;
export declare type LensPath = (<T, F>(path: Path) => Lens<T, F>) & ((path?: PH) => LensPath);
/**
 * Returns a lens whose focus is the specified path.
 *
 *      const xHeadYLens = Fae.lensPath(['x', 0, 'y'])
 *      Fae.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}) // {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
 */
export declare const lensPath: LensPath;
export declare type LensProp = (<T, F>(prop: string | number) => Lens<T, F>) & ((prop?: PH) => LensProp);
/**
 * Returns a lens whose focus is the specified property
 *
 *      const xLens = Fae.lensProp('x')
 *      Fae.view(xLens, {x: 1, y: 2})
 */
export declare const lensProp: LensProp;
export declare type Lift = ((f: Func) => Func) & ((f?: PH) => Lift);
export declare const lift: Lift;
/**
 * Lifts `fn` to a specified `arity`. The returned function applies
 * the `fn` on `arity` number of lists in all possible combination
 * of elements of the lists passe. The result is accumulated in a list
 *
 *      const add2 = Fae.liftN(3, (...args: number[]) => R.sum(args))
 *      add2([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 */
export declare const liftN: Func;
export declare type Map_2<F extends Obj<T> | Func | T[], T, R> = ((functor: F) => Func | R[] | Obj<R>) & ((functor?: PH) => Map_2<F, T, R>);
export declare type Map_1<F extends Obj<T> | Func | T[], T, R> = ((fn: FuncArr1<T, R>) => Func | R[] | Obj<R>) & ((fn?: PH) => Map_1<F, T, R>);
export declare type Map = (<F extends Obj<T> | Func | T[], T, R>(fn: FuncArr1<T, R>, functor: F) => Func | R[] | Obj<R>) & (<F extends Obj<T> | Func | T[], T, R>(fn: FuncArr1<T, R>, functor?: PH) => Map_2<F, T, R>) & (<F extends Obj<T> | Func | T[], T, R>(fn: PH, functor: F) => Map_1<F, T, R>) & ((fn?: PH, functor?: PH) => Map);
/**
 * Applies `fn` to each of `functor`'s value
 * and returns functor of same shape
 *
 * Acts as a transducer if a transformer is given in `functor`.
 */
export declare const map: Map;
export declare type Max_2<T extends number | string | Date> = ((b: T) => T) & ((b?: PH) => Max_2<T>);
export declare type Max_1<T extends number | string | Date> = ((a: T) => T) & ((a?: PH) => Max_1<T>);
export declare type Max = (<T extends number | string | Date>(a: T, b: T) => T) & (<T extends number | string | Date>(a: T, b?: PH) => Max_2<T>) & (<T extends number | string | Date>(a: PH, b: T) => Max_1<T>) & ((a?: PH, b?: PH) => Max);
/**
 * Returns the larger of its two arguments.
 *
 * NaN > 1000  // false
 *
 *      Fae.max(1, 2)  // => 2
 *      Fae.max('abd', 'abc')  // => 'abd'
 *      Fae.max(1000, NaN)  // => 1000
*/
export declare const max: Max;
export declare type Mean = ((list: number[]) => number) & ((list?: PH) => Mean);
/**
 * Returns the mean of the given list of numbers.
 */
export declare const mean: Mean;
export declare type Median = ((list: number[]) => number) & ((list?: PH) => Median);
/**
 * Returns the median of the given list of numbers.
 *  */
export declare const median: Median;
export declare type Min_2<T extends number | string | Date> = ((b: T) => T) & ((b?: PH) => Min_2<T>);
export declare type Min_1<T extends number | string | Date> = ((a: T) => T) & ((a?: PH) => Min_1<T>);
export declare type Min = (<T extends number | string | Date>(a: T, b: T) => T) & (<T extends number | string | Date>(a: T, b?: PH) => Min_2<T>) & (<T extends number | string | Date>(a: PH, b: T) => Min_1<T>) & ((a?: PH, b?: PH) => Min);
/**
 * Returns the smaller of its two arguments.
 */
export declare const min: Min;
export declare type Multiply_2 = ((b: number) => number) & ((b?: PH) => Multiply_2);
export declare type Multiply_1 = ((a: number) => number) & ((a?: PH) => Multiply_1);
export declare type Multiply = ((a: number, b: number) => number) & ((a: number, b?: PH) => Multiply_2) & ((a: PH, b: number) => Multiply_1) & ((a?: PH, b?: PH) => Multiply);
/**
 * Multiplies two numbers. Equivalent to `a * b` but curried.
 */
export declare const multiply: Multiply;
export declare type Not = (<T>(fn: T) => boolean) & ((fn?: PH) => Not);
export declare const not: Not;
export declare type Nth_2 = (<F extends FunctorWithArLk<T> | string, T>(functor: F) => T) & ((functor?: PH) => Nth_2);
export declare type Nth_1<F extends FunctorWithArLk<T> | string, T> = ((index: number) => T) & ((index?: PH) => Nth_1<F, T>);
export declare type Nth = (<F extends FunctorWithArLk<T> | string, T>(index: number, functor: F) => T) & ((index: number, functor?: PH) => Nth_2) & (<F extends FunctorWithArLk<T> | string, T>(index: PH, functor: F) => Nth_1<F, T>) & ((index?: PH, functor?: PH) => Nth);
/**
 * Returns `index`th element of `functor`.
 * Returns element counting from right end if `index` is -ve.
 * Works in array-like/string/iterable/iterator
 */
export declare const nth: Nth;
export declare type Or_2<T1> = (<T2>(b: T2) => T1 | T2) & ((b?: PH) => Or_2<T1>);
export declare type Or_1<T2> = (<T1>(a: T1) => T1 | T2) & ((a?: PH) => Or_1<T2>);
export declare type Or = (<T1, T2>(a: T1, b: T2) => T1 | T2) & (<T1>(a: T1, b?: PH) => Or_2<T1>) & (<T2>(a: PH, b: T2) => Or_1<T2>) & ((a?: PH, b?: PH) => Or);
/**
 * Returns `true` if one or both of its arguments are `true`. Returns `false`
 * if both arguments are `false`.
 *
 *      Fae.or(true, true)    //=> true
 *      Fae.or(true, false)   //=> true
 *      Fae.or(false, true)   //=> true
 *      Fae.or(false, false)  //=> false
 */
export declare const or: Or;
export declare type Over_1<T, R> = ((lens: Lens<T, R>) => T) & ((lens?: PH) => Over_1<T, R>);
export declare type Over_2<T, R> = ((fn: FuncArr1<R, R>) => T) & ((fn?: PH) => Over_2<T, R>);
export declare type Over_3<T, R> = ((target: T) => T) & ((target?: PH) => Over_3<T, R>);
export declare type Over_2_3<T, R> = ((fn: FuncArr1<R, R>, target: T) => T) & ((fn: FuncArr1<R, R>, target?: PH) => Over_3<T, R>) & ((fn: PH, target: T) => Over_2<T, R>) & ((fn?: PH, target?: PH) => Over_2_3<T, R>);
export declare type Over_1_3<R> = (<T>(lens: Lens<T, R>, target: T) => T) & (<T>(lens: Lens<T, R>, target?: PH) => Over_3<T, R>) & (<T>(lens: PH, target: T) => Over_1<T, R>) & ((lens?: PH, target?: PH) => Over_1_3<R>);
export declare type Over_1_2<T> = (<R>(lens: Lens<T, R>, fn: FuncArr1<R, R>) => T) & (<R>(lens: Lens<T, R>, fn?: PH) => Over_2<T, R>) & (<R>(lens: PH, fn: FuncArr1<R, R>) => Over_1<T, R>) & ((lens?: PH, fn?: PH) => Over_1_2<T>);
export declare type Over = (<T, R>(lens: Lens<T, R>, fn: FuncArr1<R, R>, target: T) => T) & ((lens?: PH, fn?: PH, target?: PH) => Over) & (<T, R>(lens: Lens<T, R>, fn?: PH, target?: PH) => Over_2_3<T, R>) & (<R>(lens: PH, fn: FuncArr1<R, R>, target?: PH) => Over_1_3<R>) & (<T>(lens: PH, fn: PH, target: T) => Over_1_2<T>) & (<T, R>(lens: Lens<T, R>, fn: FuncArr1<R, R>, target?: PH) => Over_3<T, R>) & (<T, R>(lens: Lens<T, R>, fn: PH, target: T) => Over_2<T, R>) & (<T, R>(lens: PH, fn: FuncArr1<R, R>, target: T) => Over_1<T, R>);
/**
 * Returns the result of "setting" the portion of the given data structure `target`
 * focused by the given `lens` to the result of applying the given function `fn` to
 * the focused value.
 *
 *      const headLens = Fae.lensIndex(0)
 *      R.over(headLens, (x: string) => x.toUpperCase(), ['foo', 'bar', 'baz']) //=> ['FOO', 'bar', 'baz']
 */
export declare const over: Over;
export declare type PathF_2 = (<T, R>(obj: ObjRec<T> | null) => R) & ((obj?: PH) => PathF_2);
export declare type PathF_1<T, R> = ((ps: Path) => R) & ((ps?: PH) => PathF_1<T, R>);
export declare type PathF = (<T, R>(ps: Path, obj: ObjRec<T> | null) => R) & ((ps: Path, obj?: PH) => PathF_2) & (<T, R>(ps: PH, obj: ObjRec<T> | null) => PathF_1<T, R>) & ((ps?: PH, obj?: PH) => PathF);
/**
 * Retrieve the value at a given path.
 * The path may be any array of keys or
 * string of keys separated by `/` or `.` .
 *
 *
 *      Fae.path(['a', 'b'], {a: {b: 2}}); 2
 *      Fae.path(['a', 'b'], {c: {b: 2}}); // undefined
 *      Fae.path('a/b/0', {a: {b: [1, 2, 3]}}); // 1
 *      Fae.path('a.b.0', {a: {b: [1, 2, 3]}}); // 2
 */
export declare const path: PathF;
export declare type PathOr_1<T> = (<D, P>(d: D) => D | P) & ((d?: PH) => PathOr_1<T>);
export declare type PathOr_2<T, D> = (<P>(p: Path) => D | P) & ((p?: PH) => PathOr_2<T, D>);
export declare type PathOr_3<D> = (<T, P>(obj: ObjRec<T> | null) => D | P) & ((obj?: PH) => PathOr_3<D>);
export declare type PathOr_2_3<D> = (<T, P>(p: Path, obj: ObjRec<T> | null) => D | P) & ((p: Path, obj?: PH) => PathOr_3<D>) & (<T>(p: PH, obj: ObjRec<T> | null) => PathOr_2<T, D>) & ((p?: PH, obj?: PH) => PathOr_2_3<D>);
export declare type PathOr_1_3 = (<T, D, P>(d: D, obj: ObjRec<T> | null) => D | P) & (<D>(d: D, obj?: PH) => PathOr_3<D>) & (<T>(d: PH, obj: ObjRec<T> | null) => PathOr_1<T>) & ((d?: PH, obj?: PH) => PathOr_1_3);
export declare type PathOr_1_2<T> = (<D, P>(d: D, p: Path) => D | P) & (<D>(d: D, p?: PH) => PathOr_2<T, D>) & ((d: PH, p: Path) => PathOr_1<T>) & ((d?: PH, p?: PH) => PathOr_1_2<T>);
export declare type PathOr = (<T, D, P>(d: D, p: Path, obj: ObjRec<T> | null) => D | P) & ((d?: PH, p?: PH, obj?: PH) => PathOr) & (<D>(d: D, p?: PH, obj?: PH) => PathOr_2_3<D>) & ((d: PH, p: Path, obj?: PH) => PathOr_1_3) & (<T>(d: PH, p: PH, obj: ObjRec<T> | null) => PathOr_1_2<T>) & (<D>(d: D, p: Path, obj?: PH) => PathOr_3<D>) & (<T, D>(d: D, p: PH, obj: ObjRec<T> | null) => PathOr_2<T, D>) & (<T>(d: PH, p: Path, obj: ObjRec<T> | null) => PathOr_1<T>);
/**
 * If the given, non-null object has a value at the given path, returns the
 * value at that path. Otherwise returns the provided default value.
 *
 *
 *      Fae.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
 *      Fae.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
 */
export declare const pathOr: PathOr;
/**
 * Performs a left-to-right function composition.
 * The first function may have any number of arguments;
 * the remaining must have single argument.
 * **Note:** The returned function is automatically curried.
 *
 */
export declare function pipe<F2 extends FuncArr1<any, any>[]>(func: Func, ...functions: F2): (this: any, ...passed: any[]) => any;
export declare type Pluck_2 = (<T>(list: Obj<T>[]) => T[]) & ((list?: PH) => Pluck_2);
export declare type Pluck_1<T> = ((p: number | string) => T[]) & ((p?: PH) => Pluck_1<T>);
export declare type Pluck = (<T>(p: number | string, list: Obj<T>[]) => T[]) & ((p: number | string, list?: PH) => Pluck_2) & (<T>(p: PH, list: Obj<T>[]) => Pluck_1<T>) & ((p?: PH, list?: PH) => Pluck);
/**
 * Returns a new list by plucking the same named property off all objects in
 * the list supplied.
 *
 *      let getAges = Fae.pluck('age')
 *      getAges([{name: 'shubham', age: 22}, {name: 'shivam', age: 23}]) //=> [22, 23]
 *
 *      Fae.pluck(0, [[1, 2], [3, 4]])               //=> [1, 3]
 *      Fae.pluck('val', {a: {val: 3}, b: {val: 5}}) //=> {a: 3, b: 5}
 */
export declare const pluck: Pluck;
export declare type Prepend_2<T> = ((list: T[]) => T[]) & ((list?: PH) => Prepend_2<T>);
export declare type Prepend_1<T> = ((el: T) => T[]) & ((el?: PH) => Prepend_1<T>);
export declare type Prepend = (<T>(el: T, list: T[]) => T[]) & (<T>(el: T, list?: PH) => Prepend_2<T>) & (<T>(el: PH, list: T[]) => Prepend_1<T>) & ((el?: PH, list?: PH) => Prepend);
/**
 * Add the `el` to the start of `list` and returns new list without affecting original
 *
 *
 *      Fae.prepend('tests', ['write', 'more']); //=> [''tests', ''write', 'more']
 *      Fae.prepend('tests', []); //=> ['tests']
 *      Fae.prepend(['tests'], ['write', 'more']); //=> [['tests'], 'write', 'more']
 */
export declare const prepend: Prepend;
export declare type Prop_2 = (<T>(obj: Obj<T> | ArrayLike<T>) => T | undefined) & ((obj?: PH) => Prop_2);
export declare type Prop_1<T> = ((p: string | number) => T | undefined) & ((p?: PH) => Prop_1<T>);
export declare type Prop = (<T>(p: string | number, obj: Obj<T> | ArrayLike<T>) => T | undefined) & ((p: string | number, obj?: PH) => Prop_2) & (<T>(p: PH, obj: Obj<T> | ArrayLike<T>) => Prop_1<T>) & ((p?: PH, obj?: PH) => Prop);
/** Returns p property `p` on the `obj` if exists */
export declare const prop: Prop;
export declare type PropEq_1<T> = ((name: string) => boolean) & ((name?: PH) => PropEq_1<T>);
export declare type PropEq_2<T> = ((val: T) => boolean) & ((val?: PH) => PropEq_2<T>);
export declare type PropEq_3<T> = ((obj: Obj<T>) => boolean) & ((obj?: PH) => PropEq_3<T>);
export declare type PropEq_2_3 = (<T>(val: T, obj: Obj<T>) => boolean) & (<T>(val: T, obj?: PH) => PropEq_3<T>) & (<T>(val: PH, obj: Obj<T>) => PropEq_2<T>) & ((val?: PH, obj?: PH) => PropEq_2_3);
export declare type PropEq_1_3<T> = ((name: string, obj: Obj<T>) => boolean) & ((name: string, obj?: PH) => PropEq_3<T>) & ((name: PH, obj: Obj<T>) => PropEq_1<T>) & ((name?: PH, obj?: PH) => PropEq_1_3<T>);
export declare type PropEq_1_2<T> = ((name: string, val: T) => boolean) & ((name: string, val?: PH) => PropEq_2<T>) & ((name: PH, val: T) => PropEq_1<T>) & ((name?: PH, val?: PH) => PropEq_1_2<T>);
export declare type PropEq = (<T>(name: string, val: T, obj: Obj<T>) => boolean) & ((name?: PH, val?: PH, obj?: PH) => PropEq) & ((name: string, val?: PH, obj?: PH) => PropEq_2_3) & (<T>(name: PH, val: T, obj?: PH) => PropEq_1_3<T>) & (<T>(name: PH, val: PH, obj: Obj<T>) => PropEq_1_2<T>) & (<T>(name: string, val: T, obj?: PH) => PropEq_3<T>) & (<T>(name: string, val: PH, obj: Obj<T>) => PropEq_2<T>) & (<T>(name: PH, val: T, obj: Obj<T>) => PropEq_1<T>);
/**
 * Returns `true` if the specified object property is equal, to the given value; `false` otherwise.
 *
 *      const shivam = {name: 'shivam', age: 20, hair: 'brown'}
 *      const shubham = {name: 'shubham', age: 22, hair: 'black'}
 *      const Krish = {name: 'krish', age: 25, hair: 'black'}
 *      const students = [shivam, shubham, krish]
 *      const hasBrownHair = Fae.propEq('hair', 'brown')
 *      Fae.filter(hasBrownHair, students) //=> [shubham]
 */
export declare const propEq: PropEq;
export declare type PropIs_1<T> = ((type: string) => boolean) & ((type?: PH) => PropIs_1<T>);
export declare type PropIs_2<T> = ((name: string) => boolean) & ((name?: PH) => PropIs_2<T>);
export declare type PropIs_3 = (<T>(obj: Obj<T>) => boolean) & ((obj?: PH) => PropIs_3);
export declare type PropIs_2_3 = (<T>(name: string, obj: Obj<T>) => boolean) & ((name: string, obj?: PH) => PropIs_3) & (<T>(name: PH, obj: Obj<T>) => PropIs_2<T>) & ((name?: PH, obj?: PH) => PropIs_2_3);
export declare type PropIs_1_3 = (<T>(type: string, obj: Obj<T>) => boolean) & ((type: string, obj?: PH) => PropIs_3) & (<T>(type: PH, obj: Obj<T>) => PropIs_1<T>) & ((type?: PH, obj?: PH) => PropIs_1_3);
export declare type PropIs_1_2<T> = ((type: string, name: string) => boolean) & ((type: string, name?: PH) => PropIs_2<T>) & ((type: PH, name: string) => PropIs_1<T>) & ((type?: PH, name?: PH) => PropIs_1_2<T>);
export declare type PropIs = (<T>(type: string, name: string, obj: Obj<T>) => boolean) & ((type?: PH, name?: PH, obj?: PH) => PropIs) & ((type: string, name?: PH, obj?: PH) => PropIs_2_3) & ((type: PH, name: string, obj?: PH) => PropIs_1_3) & (<T>(type: PH, name: PH, obj: Obj<T>) => PropIs_1_2<T>) & ((type: string, name: string, obj?: PH) => PropIs_3) & (<T>(type: string, name: PH, obj: Obj<T>) => PropIs_2<T>) & (<T>(type: PH, name: string, obj: Obj<T>) => PropIs_1<T>);
/**
 * Returns `true` if the specified object property(must be passed as string) is of the given type;
 * `false` otherwise.
 *
 *      Fae.propIs('Number', 'a', {a: 1, y: 2});  //=> true
 *      Fae.propIs('String', 'a', {a: 'foo'});    //=> true
 *      Fae.propIs('Number', 'a', {});            //=> false
 */
export declare const propIs: PropIs;
export declare type PropOr_1<T> = (<R>(d: R) => R) & ((d?: PH) => PropOr_1<T>);
export declare type PropOr_2<T, R> = ((p: string | number) => R) & ((p?: PH) => PropOr_2<T, R>);
export declare type PropOr_3<R> = (<T>(obj: Obj<T> | null) => R) & ((obj?: PH) => PropOr_3<R>);
export declare type PropOr_2_3<R> = (<T>(p: string | number, obj: Obj<T> | null) => R) & ((p: string | number, obj?: PH) => PropOr_3<R>) & (<T>(p: PH, obj: Obj<T> | null) => PropOr_2<T, R>) & ((p?: PH, obj?: PH) => PropOr_2_3<R>);
export declare type PropOr_1_3 = (<T, R>(d: R, obj: Obj<T> | null) => R) & (<R>(d: R, obj?: PH) => PropOr_3<R>) & (<T>(d: PH, obj: Obj<T> | null) => PropOr_1<T>) & ((d?: PH, obj?: PH) => PropOr_1_3);
export declare type PropOr_1_2<T> = (<R>(d: R, p: string | number) => R) & (<R>(d: R, p?: PH) => PropOr_2<T, R>) & ((d: PH, p: string | number) => PropOr_1<T>) & ((d?: PH, p?: PH) => PropOr_1_2<T>);
export declare type PropOr = (<T, R>(d: R, p: string | number, obj: Obj<T> | null) => R) & ((d?: PH, p?: PH, obj?: PH) => PropOr) & (<R>(d: R, p?: PH, obj?: PH) => PropOr_2_3<R>) & ((d: PH, p: string | number, obj?: PH) => PropOr_1_3) & (<T>(d: PH, p: PH, obj: Obj<T> | null) => PropOr_1_2<T>) & (<R>(d: R, p: string | number, obj?: PH) => PropOr_3<R>) & (<T, R>(d: R, p: PH, obj: Obj<T> | null) => PropOr_2<T, R>) & (<T>(d: PH, p: string | number, obj: Obj<T> | null) => PropOr_1<T>);
/**
 * If the given, non-null object has an own property with the specified name,
 * returns the value of that property. Otherwise returns the provided default
 * value.
 *      const alice = {
 *        name: 'Fae',
 *        age: 15
 *      };
 *      const Great = Fae.prop('GreatLibrary');
 *      const GreatWithDefault = Fae.propOr('FaeModule', 'GreatLibrary');
 *
 *      Great(Fae);  //=> undefined
 *      GreatWithDefault(Fae);  //=> 'FaeModule'
 */
export declare const propOr: PropOr;
export declare type Props_2 = (<T>(obj: Obj<T> | ArrayLike<T>) => (T | undefined)[]) & ((obj?: PH) => Props_2);
export declare type Props_1<T> = ((p: (string | number)[]) => (T | undefined)[]) & ((p?: PH) => Props_1<T>);
export declare type Props = (<T>(p: (string | number)[], obj: Obj<T> | ArrayLike<T>) => (T | undefined)[]) & ((p: (string | number)[], obj?: PH) => Props_2) & (<T>(p: PH, obj: Obj<T> | ArrayLike<T>) => Props_1<T>) & ((p?: PH, obj?: PH) => Props);
/** Returns an array of multiple on the `obj`. Order is preserved. */
export declare const props: Props;
export declare type PropSatisfies_1<T> = ((pred: Predicate1<T>) => boolean) & ((pred?: PH) => PropSatisfies_1<T>);
export declare type PropSatisfies_2<T> = ((name: string) => boolean) & ((name?: PH) => PropSatisfies_2<T>);
export declare type PropSatisfies_3<T> = ((obj: Obj<T>) => boolean) & ((obj?: PH) => PropSatisfies_3<T>);
export declare type PropSatisfies_2_3<T> = ((name: string, obj: Obj<T>) => boolean) & ((name: string, obj?: PH) => PropSatisfies_3<T>) & ((name: PH, obj: Obj<T>) => PropSatisfies_2<T>) & ((name?: PH, obj?: PH) => PropSatisfies_2_3<T>);
export declare type PropSatisfies_1_3 = (<T>(pred: Predicate1<T>, obj: Obj<T>) => boolean) & (<T>(pred: Predicate1<T>, obj?: PH) => PropSatisfies_3<T>) & (<T>(pred: PH, obj: Obj<T>) => PropSatisfies_1<T>) & ((pred?: PH, obj?: PH) => PropSatisfies_1_3);
export declare type PropSatisfies_1_2<T> = ((pred: Predicate1<T>, name: string) => boolean) & ((pred: Predicate1<T>, name?: PH) => PropSatisfies_2<T>) & ((pred: PH, name: string) => PropSatisfies_1<T>) & ((pred?: PH, name?: PH) => PropSatisfies_1_2<T>);
export declare type PropSatisfies = (<T>(pred: Predicate1<T>, name: string, obj: Obj<T>) => boolean) & ((pred?: PH, name?: PH, obj?: PH) => PropSatisfies) & (<T>(pred: Predicate1<T>, name?: PH, obj?: PH) => PropSatisfies_2_3<T>) & ((pred: PH, name: string, obj?: PH) => PropSatisfies_1_3) & (<T>(pred: PH, name: PH, obj: Obj<T>) => PropSatisfies_1_2<T>) & (<T>(pred: Predicate1<T>, name: string, obj?: PH) => PropSatisfies_3<T>) & (<T>(pred: Predicate1<T>, name: PH, obj: Obj<T>) => PropSatisfies_2<T>) & (<T>(pred: PH, name: string, obj: Obj<T>) => PropSatisfies_1<T>);
/**
 * Returns `true` if the specified object property satisfies the given
 * predicate; `false` otherwise.
 *
 *      Fae.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
 */
export declare const propSatisfies: PropSatisfies;
export declare type Range_2 = ((to: number) => number[]) & ((to?: PH) => Range_2);
export declare type Range_1 = ((from: number) => number[]) & ((from?: PH) => Range_1);
export declare type Range = ((from: number, to: number) => number[]) & ((from: number, to?: PH) => Range_2) & ((from: PH, to: number) => Range_1) & ((from?: PH, to?: PH) => Range);
/** Returns a list of numbers from `from` to `to` **both inclusive**. */
export declare const range: Range;
export declare type RangeUntil_2 = ((to: number) => number[]) & ((to?: PH) => RangeUntil_2);
export declare type RangeUntil_1 = ((from: number) => number[]) & ((from?: PH) => RangeUntil_1);
export declare type RangeUntil = ((from: number, to: number) => number[]) & ((from: number, to?: PH) => RangeUntil_2) & ((from: PH, to: number) => RangeUntil_1) & ((from?: PH, to?: PH) => RangeUntil);
/** Returns a list of numbers from `from` (**inclusive**) to `to` (**exclusive**). */
export declare const rangeUntil: RangeUntil;
declare class Transformer {
	protected transformer?: Transformer;
	protected f: Func;
	static transform: symbol;
	constructor(f: Func, transformer?: Transformer);
	init(): any;
	result(acc: any): any;
	step(result: any, input: any): any;
}
declare class ReducedTransformer<T> {
	private _value;
	constructor(value: T);
	get value(): T;
}
export declare type Reduce_1<T, R> = (<P>(func: FuncArr2<R, P, R | ReducedTransformer<R>> | Transformer) => R) & ((func?: PH) => Reduce_1<T, R>);
export declare type Reduce_2<T, R, P> = ((acc: R) => R) & ((acc?: PH) => Reduce_2<T, R, P>);
export declare type Reduce_3<R, P> = (<T>(functor: FunctorWithArLk<T>) => R) & ((functor?: PH) => Reduce_3<R, P>);
export declare type Reduce_2_3<R, P> = (<T>(acc: R, functor: FunctorWithArLk<T>) => R) & ((acc: R, functor?: PH) => Reduce_3<R, P>) & (<T>(acc: PH, functor: FunctorWithArLk<T>) => Reduce_2<T, R, P>) & ((acc?: PH, functor?: PH) => Reduce_2_3<R, P>);
export declare type Reduce_1_3<R> = (<T, P>(func: FuncArr2<R, P, R | ReducedTransformer<R>> | Transformer, functor: FunctorWithArLk<T>) => R) & (<P>(func: FuncArr2<R, P, R | ReducedTransformer<R>> | Transformer, functor?: PH) => Reduce_3<R, P>) & (<T>(func: PH, functor: FunctorWithArLk<T>) => Reduce_1<T, R>) & ((func?: PH, functor?: PH) => Reduce_1_3<R>);
export declare type Reduce_1_2<T> = (<R, P>(func: FuncArr2<R, P, R | ReducedTransformer<R>> | Transformer, acc: R) => R) & (<R, P>(func: FuncArr2<R, P, R | ReducedTransformer<R>> | Transformer, acc?: PH) => Reduce_2<T, R, P>) & (<R>(func: PH, acc: R) => Reduce_1<T, R>) & ((func?: PH, acc?: PH) => Reduce_1_2<T>);
export declare type Reduce = (<T, R, P>(func: FuncArr2<R, P, R | ReducedTransformer<R> | ReducedTransformer<R>> | Transformer, acc: R, functor: FunctorWithArLk<T>) => R) & ((func?: PH, acc?: PH, functor?: PH) => Reduce) & (<R, P>(func: FuncArr2<R, P, R | ReducedTransformer<R>> | Transformer, acc?: PH, functor?: PH) => Reduce_2_3<R, P>) & (<R>(func: PH, acc: R, functor?: PH) => Reduce_1_3<R>) & (<T>(func: PH, acc: PH, functor: FunctorWithArLk<T>) => Reduce_1_2<T>) & (<R, P>(func: FuncArr2<R, P, R | ReducedTransformer<R>> | Transformer, acc: R, functor?: PH) => Reduce_3<R, P>) & (<T, R, P>(func: FuncArr2<R, P, R | ReducedTransformer<R>> | Transformer, acc: PH, functor: FunctorWithArLk<T>) => Reduce_2<T, R, P>) & (<T, R>(func: PH, acc: R, functor: FunctorWithArLk<T>) => Reduce_1<T, R>);
/**
 * Returns a single value by iterating though `functor`
 * calling the iterator function `func`. `func` takes two arguments.
 * First - `acc`, Second - `value`.
 *
 * It may stop the reduction in between by means of `ReducedTransformer`.
 *
 * Acts as a transducer if a transformer is given in `functor`.
 *
 * Works on array-like/iterable/iterator
 */
export declare const reduce: Reduce;
export declare type Reject_2<T> = (<F extends T[] | Obj<T>>(filterable: F) => F) & ((filterable?: PH) => Reject_2<T>);
export declare type Reject_1<F extends T[] | Obj<T>, T> = ((predicate: Predicate1<T>) => F) & ((predicate?: PH) => Reject_1<F, T>);
export declare type Reject = (<F extends T[] | Obj<T>, T>(predicate: Predicate1<T>, filterable: F) => F) & (<T>(predicate: Predicate1<T>, filterable?: PH) => Reject_2<T>) & (<F extends T[] | Obj<T>, T>(predicate: PH, filterable: F) => Reject_1<F, T>) & ((predicate?: PH, filterable?: PH) => Reject);
/**
 * works as the complement of filter
 *
 *      const isOdd = n => (n & 1) === 1;
 *      const f = Fae.reject(isOdd, [1, 2, 3, 4])
 *      f() // [2, 4]
 */
export declare const reject: Reject;
export declare type Reverse = (<F extends T[] | string, T>(functor: F) => F) & ((fn?: PH) => Reverse);
/** Reverses given string or array without affecting the original. */
export declare const reverse: Reverse;
export declare type Set_1<T, F> = ((lens: Lens<T, F>) => T) & ((lens?: PH) => Set_1<T, F>);
export declare type Set_2<T, F> = ((value: F) => T) & ((value?: PH) => Set_2<T, F>);
export declare type Set_3<T, F> = ((target: T) => T) & ((target?: PH) => Set_3<T, F>);
export declare type Set_2_3<T, F> = ((value: F, target: T) => T) & ((value: F, target?: PH) => Set_3<T, F>) & ((value: PH, target: T) => Set_2<T, F>) & ((value?: PH, target?: PH) => Set_2_3<T, F>);
export declare type Set_1_3<F> = (<T>(lens: Lens<T, F>, target: T) => T) & (<T>(lens: Lens<T, F>, target?: PH) => Set_3<T, F>) & (<T>(lens: PH, target: T) => Set_1<T, F>) & ((lens?: PH, target?: PH) => Set_1_3<F>);
export declare type Set_1_2<T> = (<F>(lens: Lens<T, F>, value: F) => T) & (<F>(lens: Lens<T, F>, value?: PH) => Set_2<T, F>) & (<F>(lens: PH, value: F) => Set_1<T, F>) & ((lens?: PH, value?: PH) => Set_1_2<T>);
export declare type Set = (<T, F>(lens: Lens<T, F>, value: F, target: T) => T) & ((lens?: PH, value?: PH, target?: PH) => Set) & (<T, F>(lens: Lens<T, F>, value?: PH, target?: PH) => Set_2_3<T, F>) & (<F>(lens: PH, value: F, target?: PH) => Set_1_3<F>) & (<T>(lens: PH, value: PH, target: T) => Set_1_2<T>) & (<T, F>(lens: Lens<T, F>, value: F, target?: PH) => Set_3<T, F>) & (<T, F>(lens: Lens<T, F>, value: PH, target: T) => Set_2<T, F>) & (<T, F>(lens: PH, value: F, target: T) => Set_1<T, F>);
/**
 * Returns the result of "setting" the portion of the given data structure `target`
 * focused by the given `len`s to the given `value`.
 *
 *      const xLens = Fae.lensProp('x')
 *      Fae.set(xLens, 4, {x: 1, y: 2})  //=> {x: 4, y: 2}
 *      Fae.set(xLens, 8, {x: 1, y: 2})  //=> {x: 8, y: 2}
 */
export declare const set: Set;
export declare type Slice_1<L extends ArrayLike<T> | string, T = any> = ((fromIndex: number) => L) & ((fromIndex?: PH) => Slice_1<L, T>);
export declare type Slice_2<L extends ArrayLike<T> | string, T = any> = ((toIndex: number) => L) & ((toIndex?: PH) => Slice_2<L, T>);
export declare type Slice_3 = (<L extends ArrayLike<T> | string, T = any>(list: L) => L) & ((list?: PH) => Slice_3);
export declare type Slice_2_3 = (<L extends ArrayLike<T> | string, T = any>(toIndex: number, list: L) => L) & ((toIndex: number, list?: PH) => Slice_3) & (<L extends ArrayLike<T> | string, T = any>(toIndex: PH, list: L) => Slice_2<L, T>) & ((toIndex?: PH, list?: PH) => Slice_2_3);
export declare type Slice_1_3 = (<L extends ArrayLike<T> | string, T = any>(fromIndex: number, list: L) => L) & ((fromIndex: number, list?: PH) => Slice_3) & (<L extends ArrayLike<T> | string, T = any>(fromIndex: PH, list: L) => Slice_1<L, T>) & ((fromIndex?: PH, list?: PH) => Slice_1_3);
export declare type Slice_1_2<L extends ArrayLike<T> | string, T = any> = ((fromIndex: number, toIndex: number) => L) & ((fromIndex: number, toIndex?: PH) => Slice_2<L, T>) & ((fromIndex: PH, toIndex: number) => Slice_1<L, T>) & ((fromIndex?: PH, toIndex?: PH) => Slice_1_2<L, T>);
export declare type Slice = (<L extends ArrayLike<T> | string, T = any>(fromIndex: number, toIndex: number, list: L) => L) & ((fromIndex?: PH, toIndex?: PH, list?: PH) => Slice) & ((fromIndex: number, toIndex?: PH, list?: PH) => Slice_2_3) & ((fromIndex: PH, toIndex: number, list?: PH) => Slice_1_3) & (<L extends ArrayLike<T> | string, T = any>(fromIndex: PH, toIndex: PH, list: L) => Slice_1_2<L, T>) & ((fromIndex: number, toIndex: number, list?: PH) => Slice_3) & (<L extends ArrayLike<T> | string, T = any>(fromIndex: number, toIndex: PH, list: L) => Slice_2<L, T>) & (<L extends ArrayLike<T> | string, T = any>(fromIndex: PH, toIndex: number, list: L) => Slice_1<L, T>);
/** Returns the elements of the given list or string `fromIndex` (inclusive) to `toIndex` (exclusive). */
export declare const slice: Slice;
export declare type Sort_2<T> = ((list: T[]) => T[]) & ((list?: PH) => Sort_2<T>);
export declare type Sort_1<T> = ((comparator: Comparator<T>) => T[]) & ((comparator?: PH) => Sort_1<T>);
export declare type Sort = (<T>(comparator: Comparator<T>, list: T[]) => T[]) & (<T>(comparator: Comparator<T>, list?: PH) => Sort_2<T>) & (<T>(comparator: PH, list: T[]) => Sort_1<T>) & ((comparator?: PH, list?: PH) => Sort);
/**
 * Returns a copy of the list, sorted according to the comparator function,
 * which should accept two values at a time and return a negative number if the
 * first value is smaller, a positive number if it's larger, and zero if they
 * are equal.
 *
 * It does not modify the original.
 */
export declare const sort: Sort;
export declare type Subtract_2 = ((b: number) => number) & ((b?: PH) => Subtract_2);
export declare type Subtract_1 = ((a: number) => number) & ((a?: PH) => Subtract_1);
export declare type Subtract = ((a: number, b: number) => number) & ((a: number, b?: PH) => Subtract_2) & ((a: PH, b: number) => Subtract_1) & ((a?: PH, b?: PH) => Subtract);
/** Subtracts its second argument from its first argument. */
export declare const subtract: Subtract;
export declare type Sum = ((list: number[]) => number) & ((list?: PH) => Sum);
/** Adds together all the elements of a list. */
export declare const sum: Sum;
export declare type Tail = (<F extends ArrayLike<T> | string, T>(functor: F) => F) & ((functor?: PH) => Tail);
/**
 * Returns all but the first element of `functor`.
 * Accepts array-like(including string).
 */
export declare const tail: Tail;
export declare type Take_2 = (<L extends ArrayLike<T> | string, T>(list: L) => L) & ((list?: PH) => Take_2);
export declare type Take_1<L extends ArrayLike<T> | string, T> = ((n: number) => L) & ((n?: PH) => Take_1<L, T>);
export declare type Take = (<L extends ArrayLike<T> | string, T>(n: number, list: L) => L) & ((n: number, list?: PH) => Take_2) & (<L extends ArrayLike<T> | string, T>(n: PH, list: L) => Take_1<L, T>) & ((n?: PH, list?: PH) => Take);
/**
 * Returns first `n` elements of the array or string.
 *
 * Acts as a transducer if a transformer is given in `list`.
 */
export declare const take: Take;
export declare type TakeLast_2 = (<F extends T[] | string, T>(functor: F) => F) & ((functor?: PH) => TakeLast_2);
export declare type TakeLast_1<F extends T[] | string, T> = ((n: number) => F) & ((n?: PH) => TakeLast_1<F, T>);
export declare type TakeLast = (<F extends T[] | string, T>(n: number, functor: F) => F) & ((n: number, functor?: PH) => TakeLast_2) & (<F extends T[] | string, T>(n: PH, functor: F) => TakeLast_1<F, T>) & ((n?: PH, functor?: PH) => TakeLast);
export declare const takeLast: TakeLast;
export declare type Tap_2<T> = ((obj: T) => T) & ((obj?: PH) => Tap_2<T>);
export declare type Tap_1<T> = ((func: (obj: T) => any) => T) & ((func?: PH) => Tap_1<T>);
export declare type Tap = (<T>(func: (obj: T) => any, obj: T) => T) & (<T>(func: (obj: T) => any, obj?: PH) => Tap_2<T>) & (<T>(func: PH, obj: T) => Tap_1<T>) & ((func?: PH, obj?: PH) => Tap);
/** Runs the given function `func` with the supplied object `obj`, then returns `obj`. */
export declare const tap: Tap;
/**
 * Initializes a transducer using supplied iterator function `trans2`.
 * Returns a single item by iterating through the list,
 * successively calling the transformed `trans2` and passing it `acc`
 * and the current value from the array, and then passing through `trans1`
 * and then passing the result to the next call.
 *
 *
 *      const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *      const t1 = Fae.pipe(
 *        Fae.map(inc),
 *        Fae.filter(even),
 *        Fae.take(2)
 *      )
 *      t1(arr) // [2, 4]
 *      Fae.transduce(t1, Fae.flip(Fae.append), [], arr) // [3]
 */
export declare function transduce<T, L = T>(trans1: Func, trans2: Func | Transformer, acc: T, functor: L[]): T;
export declare type Trim_2 = ((t: string) => string) & ((t?: PH) => Trim_2);
export declare type Trim_1 = ((str: string) => string) & ((str?: PH) => Trim_1);
export declare type Trim = ((str: string, t: string) => string) & ((str: string, t?: PH) => Trim_2) & ((str: PH, t: string) => Trim_1) & ((str?: PH, t?: PH) => Trim);
/**
 * Trims the string `str` from both end with `t`.
 * Trims with white space if `t` is [''], with `t` otherwise.
 *
 *      Fae.trim('   xyz  ', ''); // 'xyz
 *      Fae.trim('[[Hello]]]', '[') // Hello]]]
 *      Fae.trim('[[Hello]]]', ']]') // [[Hello]]
 */
export declare const trim: Trim;
/**
 * Gives a single-word string description of the (native) type of a value.
 * The returned types are of type `AllTypes`
 *
 *
 *      Fae.typ({}); //=> "Object"
 *      Fae.typ(1); //=> "Number"
 *      Fae.typ(false); //=> "Boolean"
 *      Fae.typ('s'); //=> "String"
 *      Fae.typ(null); //=> "Null"
 *      Fae.typ([]); //=> "Array"
 *      Fae.typ(/[A-z]/); //=> "RegExp"
 *      Fae.typ(() => {}); //=> "Function"
 *      Fae.typ(undefined); //=> "Undefined"
 */
export declare function typ(a: any): AllTypes;
export declare type Until_1<T> = ((pred: Predicate1<T>) => T) & ((pred?: PH) => Until_1<T>);
export declare type Until_2<T> = ((fn: FuncArr1<T, T>) => T) & ((fn?: PH) => Until_2<T>);
export declare type Until_3<T> = ((init: T) => T) & ((init?: PH) => Until_3<T>);
export declare type Until_2_3<T> = ((fn: FuncArr1<T, T>, init: T) => T) & ((fn: FuncArr1<T, T>, init?: PH) => Until_3<T>) & (<T>(fn: PH, init: T) => Until_2<T>) & ((fn?: PH, init?: PH) => Until_2_3<T>);
export declare type Until_1_3<T> = ((pred: Predicate1<T>, init: T) => T) & ((pred: Predicate1<T>, init?: PH) => Until_3<T>) & (<T>(pred: PH, init: T) => Until_1<T>) & ((pred?: PH, init?: PH) => Until_1_3<T>);
export declare type Until_1_2<T> = ((pred: Predicate1<T>, fn: FuncArr1<T, T>) => T) & ((pred: Predicate1<T>, fn?: PH) => Until_2<T>) & ((pred: PH, fn: FuncArr1<T, T>) => Until_1<T>) & ((pred?: PH, fn?: PH) => Until_1_2<T>);
export declare type Until = (<T>(pred: Predicate1<T>, fn: FuncArr1<T, T>, init: T) => T) & ((pred?: PH, fn?: PH, init?: PH) => Until) & (<T>(pred: Predicate1<T>, fn?: PH, init?: PH) => Until_2_3<T>) & (<T>(pred: PH, fn: FuncArr1<T, T>, init?: PH) => Until_1_3<T>) & (<T>(pred: PH, fn: PH, init: T) => Until_1_2<T>) & (<T>(pred: Predicate1<T>, fn: FuncArr1<T, T>, init?: PH) => Until_3<T>) & (<T>(pred: Predicate1<T>, fn: PH, init: T) => Until_2<T>) & (<T>(pred: PH, fn: FuncArr1<T, T>, init: T) => Until_1<T>);
/**
 * Takes a predicate, a transformation function, and an initial value,
 * and returns a value of the same type as the initial value.
 */
export declare const until: Until;
export declare type Update_1<T> = ((index: number) => T[]) & ((index?: PH) => Update_1<T>);
export declare type Update_2<T> = ((value: T) => T[]) & ((value?: PH) => Update_2<T>);
export declare type Update_3<T> = ((list: T[]) => T[]) & ((list?: PH) => Update_3<T>);
export declare type Update_2_3 = (<T>(value: T, list: T[]) => T[]) & (<T>(value: T, list?: PH) => Update_3<T>) & (<T>(value: PH, list: T[]) => Update_2<T>) & ((value?: PH, list?: PH) => Update_2_3);
export declare type Update_1_3<T> = ((index: number, list: T[]) => T[]) & ((index: number, list?: PH) => Update_3<T>) & ((index: PH, list: T[]) => Update_1<T>) & ((index?: PH, list?: PH) => Update_1_3<T>);
export declare type Update_1_2<T> = ((index: number, value: T) => T[]) & ((index: number, value?: PH) => Update_2<T>) & ((index: PH, value: T) => Update_1<T>) & ((index?: PH, value?: PH) => Update_1_2<T>);
export declare type Update = (<T>(index: number, value: T, list: T[]) => T[]) & ((index?: PH, value?: PH, list?: PH) => Update) & ((index: number, value?: PH, list?: PH) => Update_2_3) & (<T>(index: PH, value: T, list?: PH) => Update_1_3<T>) & (<T>(index: PH, value: PH, list: T[]) => Update_1_2<T>) & (<T>(index: number, value: T, list?: PH) => Update_3<T>) & (<T>(index: number, value: PH, list: T[]) => Update_2<T>) & (<T>(index: PH, value: T, list: T[]) => Update_1<T>);
/**
 * Returns a new array with copy of `list` and `value` replaced at `index`.
 *
 *
 *      Fae.adjust(2, Fae.add(1), [0, 1, 2, 3]) // [0, 1, 3, 3]
 *      Fae.adjust(-3, Fae.add(1), [0, 1, 2, 3]) // [0, 2, 2, 3]
 */
export declare const update: Update;
export declare type View_2<T, F> = ((target: T) => F) & ((target?: PH) => View_2<T, F>);
export declare type View_1<T> = (<F>(lens: Lens<T, F>) => F) & ((lens?: PH) => View_1<T>);
export declare type View = (<T, F>(lens: Lens<T, F>, target: T) => F) & (<T, F>(lens: Lens<T, F>, target?: PH) => View_2<T, F>) & (<T>(lens: PH, target: T) => View_1<T>) & ((lens?: PH, target?: PH) => View);
export declare const view: View;
export declare type When_1<T, R> = ((predicate: Predicate1<T>) => T | R) & ((predicate?: PH) => When_1<T, R>);
export declare type When_2<T> = (<R>(func: FuncArr1<T, R>) => T | R) & ((func?: PH) => When_2<T>);
export declare type When_3<T, R> = ((value: T) => T | R) & ((value?: PH) => When_3<T, R>);
export declare type When_2_3<T> = (<R>(func: FuncArr1<T, R>, value: T) => T | R) & (<R>(func: FuncArr1<T, R>, value?: PH) => When_3<T, R>) & ((func: PH, value: T) => When_2<T>) & ((func?: PH, value?: PH) => When_2_3<T>);
export declare type When_1_3<T, R> = ((predicate: Predicate1<T>, value: T) => T | R) & ((predicate: Predicate1<T>, value?: PH) => When_3<T, R>) & ((predicate: PH, value: T) => When_1<T, R>) & ((predicate?: PH, value?: PH) => When_1_3<T, R>);
export declare type When_1_2<T> = (<R>(predicate: Predicate1<T>, func: FuncArr1<T, R>) => T | R) & ((predicate: Predicate1<T>, func?: PH) => When_2<T>) & (<R>(predicate: PH, func: FuncArr1<T, R>) => When_1<T, R>) & ((predicate?: PH, func?: PH) => When_1_2<T>);
export declare type When = (<T, R>(predicate: Predicate1<T>, func: FuncArr1<T, R>, value: T) => T | R) & ((predicate?: PH, func?: PH, value?: PH) => When) & (<T>(predicate: Predicate1<T>, func?: PH, value?: PH) => When_2_3<T>) & (<T, R>(predicate: PH, func: FuncArr1<T, R>, value?: PH) => When_1_3<T, R>) & (<T>(predicate: PH, func: PH, value: T) => When_1_2<T>) & (<T, R>(predicate: Predicate1<T>, func: FuncArr1<T, R>, value?: PH) => When_3<T, R>) & (<T>(predicate: Predicate1<T>, func: PH, value: T) => When_2<T>) & (<T, R>(predicate: PH, func: FuncArr1<T, R>, value: T) => When_1<T, R>);
/**
 * Applies `func` on `value` if the test `predicate` is true and returns it;
 * returns `value` otherwise.
 *
 *
 *      const truncate = Fae.when(
 *        Fae.propSatisfies(Fae.gt(Fae._, 10), 'length'),
 *        Fae.pipe(Fae.take(10), Fae.append(''), Fae.join(''))
 *      );
 *      truncate('12345');         //=> '12345'
 *      truncate('0123456789ABC'); //=> '0123456789'
 */
export declare const when: When;
export declare type Where_2<T> = ((testObj: Obj<T>) => boolean) & ((testObj?: PH) => Where_2<T>);
export declare type Where_1<T> = ((specs: Tests<T>) => boolean) & ((specs?: PH) => Where_1<T>);
export declare type Where = (<T>(specs: Tests<T>, testObj: Obj<T>) => boolean) & (<T>(specs: Tests<T>, testObj?: PH) => Where_2<T>) & (<T>(specs: PH, testObj: Obj<T>) => Where_1<T>) & ((specs?: PH, testObj?: PH) => Where);
export declare const where: Where;
export declare type WhereAll_2<T> = ((testObj: Obj<T>) => boolean) & ((testObj?: PH) => WhereAll_2<T>);
export declare type WhereAll_1<T> = ((specs: Tests<T>) => boolean) & ((specs?: PH) => WhereAll_1<T>);
export declare type WhereAll = (<T>(specs: Tests<T>, testObj: Obj<T>) => boolean) & (<T>(specs: Tests<T>, testObj?: PH) => WhereAll_2<T>) & (<T>(specs: PH, testObj: Obj<T>) => WhereAll_1<T>) & ((specs?: PH, testObj?: PH) => WhereAll);
/**
 * Takes a specs objects whose each of the spec's own properties is a predicate function
 * Each predicate is applied to the value of the corresponding property of the
 * test object. Returns `true` if all the predicates are satisfied, `false` otherwise.
 * **NOTE** returns `false` if there is no predicated functions
 *
 *
 *      const equals = curry(2, (x: number, y: number) => x === y)
 *      const spec = {x: equals(100), y: equals(20)}
 *      Fae.whereAll(spec, {x: 0, y: 200}) // false
 *      Fae.whereAll(spec, {x: 0, y: 10}) // false
 *      Fae.whereAll(spec, {x: 0, y: 2}) // true
 *      Fae.whereAll(spec, {x: 1, y: 2}) // false
 */
export declare const whereAll: WhereAll;
export declare type WhereAny_2<T> = ((testObj: Obj<T>) => boolean) & ((testObj?: PH) => WhereAny_2<T>);
export declare type WhereAny_1<T> = ((specs: Tests<T>) => boolean) & ((specs?: PH) => WhereAny_1<T>);
export declare type WhereAny = (<T>(specs: Tests<T>, testObj: Obj<T>) => boolean) & (<T>(specs: Tests<T>, testObj?: PH) => WhereAny_2<T>) & (<T>(specs: PH, testObj: Obj<T>) => WhereAny_1<T>) & ((specs?: PH, testObj?: PH) => WhereAny);
/**
 * Takes a specs objects whose each of the spec's own properties is a predicate function
 * Each predicate is applied to the value of the corresponding property of the
 * test object. Returns `true` if any of the predicates is satisfied, `false` otherwise.
 * **NOTE** returns `false` if there is no predicated functions
 *
 *
 *      const equals = curry(2, (x: number, y: number) => x === y)
 *      const spec = {x: equals(0), y: equals(20)}
 *      Fae.whereAny(spec, {x: 0, y: 200}) // true
 *      Fae.whereAny(spec, {x: 0, y: 10}) // true
 *      Fae.whereAny(spec, {x: 1, y: 101}) // false
 *      Fae.whereAny(spec, {x: 1, y: 2}) // true
 */
export declare const whereAny: WhereAny;
export declare type WhereEq_2<T> = ((testObj: Obj<T>) => boolean) & ((testObj?: PH) => WhereEq_2<T>);
export declare type WhereEq_1<T> = ((spec: Obj<T>) => boolean) & ((spec?: PH) => WhereEq_1<T>);
export declare type WhereEq = (<T>(spec: Obj<T>, testObj: Obj<T>) => boolean) & (<T>(spec: Obj<T>, testObj?: PH) => WhereEq_2<T>) & (<T>(spec: PH, testObj: Obj<T>) => WhereEq_1<T>) & ((spec?: PH, testObj?: PH) => WhereEq);
/**
 * Takes a spec object and a test object, returns true if the test satisfies
 * the spec, false otherwise.
 * `whereEq` is a specialization of [`where`].
 *
 *      const pred = Fae.whereEq({a: 1, b: 2})
 *
 *      pred({a: 1})              //=> false
 *      pred({a: 1, b: 2})        //=> true
 *      pred({a: 1, b: 2, c: 3})  //=> true
 *      pred({a: 1, b: 1})        //=> false
 */
export declare const whereEq: WhereEq;
export declare type Xor_2 = ((b: any) => boolean) & ((b?: PH) => Xor_2);
export declare type Xor_1 = ((a: any) => boolean) & ((a?: PH) => Xor_1);
export declare type Xor = ((a: any, b: any) => boolean) & ((a: any, b?: PH) => Xor_2) & ((a: PH, b: any) => Xor_1) & ((a?: PH, b?: PH) => Xor);
/**
 * Exclusive Or - Returns `true` if one of the arguments is truthy and the other is falsy.
 * Otherwise, it returns `false`.
 *
 *      Fae.xor(true, true) //=> false
 *      Fae.xor(true, false) //=> true
 *      Fae.xor(false, true) //=> true
 *      Fae.xor(false, false) //=> false
 */
export declare const xor: Xor;
export declare type Zip_2<T1> = (<T2>(list2: T2[]) => [
	T1,
	T2
][]) & ((list2?: PH) => Zip_2<T1>);
export declare type Zip_1<T2> = (<T1>(list1: T1[]) => [
	T1,
	T2
][]) & ((list1?: PH) => Zip_1<T2>);
export declare type Zip = (<T1, T2>(list1: T1[], list2: T2[]) => [
	T1,
	T2
][]) & (<T1>(list1: T1[], list2?: PH) => Zip_2<T1>) & (<T2>(list1: PH, list2: T2[]) => Zip_1<T2>) & ((list1?: PH, list2?: PH) => Zip);
/**
 * Creates a new list out of two passed lists `list1`, `list2` by pairing up
 * equally-positioned pair in both the lists.
 * The returned is truncated to the length of the shorter of the two input lists.
 *
 *
 *      Fae.zip([100, 200, 300], [1, 2, 3]) // [[1, 100], [2, 200], [3, 300]]
 */
export declare const zip: Zip;
export declare type ZipObj_2 = (<T>(values: T[]) => Obj<T>) & ((values?: PH) => ZipObj_2);
export declare type ZipObj_1<T> = ((keys: string[]) => Obj<T>) & ((keys?: PH) => ZipObj_1<T>);
export declare type ZipObj = (<T>(keys: string[], values: T[]) => Obj<T>) & ((keys: string[], values?: PH) => ZipObj_2) & (<T>(keys: PH, values: T[]) => ZipObj_1<T>) & ((keys?: PH, values?: PH) => ZipObj);
/**
 * Returns a new object out of given list of `keys` and `values`.
 * The returned is truncated to the length of the shorter of the two.
 *
 *
 *      Fae.zipObj(['a', 'b', 'c'], [1, 2, 3]) // {a: 1, b: 2, c: 3}
 */
export declare const zipObj: ZipObj;
export declare type ZipWith_1<T1, T2> = (<R>(fn: (a: T1, b: T2) => R) => R[]) & ((fn?: PH) => ZipWith_1<T1, T2>);
export declare type ZipWith_2<T1, T2, R> = ((list1: T1[]) => R[]) & ((list1?: PH) => ZipWith_2<T1, T2, R>);
export declare type ZipWith_3<T1, T2, R> = ((list2: T2[]) => R[]) & ((list2?: PH) => ZipWith_3<T1, T2, R>);
export declare type ZipWith_2_3<T1, T2, R> = ((list1: T1[], list2: T2[]) => R[]) & ((list1: T1[], list2?: PH) => ZipWith_3<T1, T2, R>) & (<L extends ArrayLike<T> | string, T = any>(list1: PH, list2: T2[]) => ZipWith_2<T1, T2, R>) & ((list1?: PH, list2?: PH) => ZipWith_2_3<T1, T2, R>);
export declare type ZipWith_1_3<T1> = (<T2, R>(fn: (a: T1, b: T2) => R, list2: T2[]) => R[]) & (<T2, R>(fn: (a: T1, b: T2) => R, list2?: PH) => ZipWith_3<T1, T2, R>) & (<T2>(fn: PH, list2: T2[]) => ZipWith_1<T1, T2>) & ((fn?: PH, list2?: PH) => ZipWith_1_3<T1>);
export declare type ZipWith_1_2<T2> = (<T1, R>(fn: (a: T1, b: T2) => R, list1: T1[]) => R[]) & (<T1, R>(fn: (a: T1, b: T2) => R, list1?: PH) => ZipWith_2<T1, T2, R>) & (<T1>(fn: PH, list1: T1[]) => ZipWith_1<T1, T2>) & ((fn?: PH, list1?: PH) => ZipWith_1_2<T2>);
export declare type ZipWith = (<T1, T2, R>(fn: (a: T1, b: T2) => R, list1: T1[], list2: T2[]) => R[]) & ((fn?: PH, list1?: PH, list2?: PH) => ZipWith) & (<T1, T2, R>(fn: (a: T1, b: T2) => R, list1?: PH, list2?: PH) => ZipWith_2_3<T1, T2, R>) & (<T1>(fn: PH, list1: T1[], list2?: PH) => ZipWith_1_3<T1>) & (<T2>(fn: PH, list1: PH, list2: T2[]) => ZipWith_1_2<T2>) & (<T1, T2, R>(fn: (a: T1, b: T2) => R, list1: T1[], list2?: PH) => ZipWith_3<T1, T2, R>) & (<T1, T2, R>(fn: (a: T1, b: T2) => R, list1: PH, list2: T2[]) => ZipWith_2<T1, T2, R>) & (<T1, T2>(fn: PH, list1: T1[], list2: T2[]) => ZipWith_1<T1, T2>);
/**
 * Creates a new list out of two passed lists `list1`, `list2`.
 * Each item of new list is calculated by applying equally-positioned pair
 * in both the lists.
 * The returned is truncated to the length of the shorter of the two input lists.
 *
 *
 *      Fae.zipWith(Fae.add, [100, 200, 300], [1, 2, 3]) // [101, 202, 303]
 */
export declare const zipWith: ZipWith;

export {};
